{"version":3,"file":"static/chunks/5024-66808cc1093f7fb1.js","mappings":"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","sources":["webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/active-editor-manager.js","webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/block-range.js","webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/common-operations.js","webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/filesys.js","webpack://_N_E/../../node_modules/hotkeys-js/dist/hotkeys.esm.js","webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/hotkey.js","webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/drag-and-drop.js","webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/event.js","webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/reordering.js","webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/index.js","webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/query.js","webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/rect.js","webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/selection.js","webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/std.js","webpack://_N_E/../../node_modules/@blocksuite/blocks/dist/__internal__/utils/types.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/consts.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/utils/attribute-renderer.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/components/virgo-element.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/components/virgo-line.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/components/virgo-text.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/components/index.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/utils/base-attributes.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/utils/delta-convert.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/utils/guard.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/utils/text.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/utils/point-conversion.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/utils/query.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/utils/selection.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/utils/range-conversion.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/utils/renderer.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/utils/index.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/services/attribute.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/services/delta.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/utils/transform-input.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/services/event.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/services/range.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/services/index.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/virgo.js","webpack://_N_E/../../node_modules/@blocksuite/virgo/dist/index.js","webpack://_N_E/../../node_modules/lit-html/directive-helpers.js","webpack://_N_E/../../node_modules/lit-html/directive.js","webpack://_N_E/../../node_modules/@lit/reactive-element/decorators/custom-element.js","webpack://_N_E/../../node_modules/@lit/reactive-element/decorators/property.js","webpack://_N_E/../../node_modules/@lit/reactive-element/decorators/state.js","webpack://_N_E/../../node_modules/@lit/reactive-element/decorators/base.js","webpack://_N_E/../../node_modules/@lit/reactive-element/decorators/query.js","webpack://_N_E/../../node_modules/@lit/reactive-element/decorators/query-all.js","webpack://_N_E/../../node_modules/@lit/reactive-element/decorators/query-assigned-elements.js","webpack://_N_E/../../node_modules/@lit/reactive-element/decorators/query-assigned-nodes.js","webpack://_N_E/../../node_modules/lit/decorators.js","webpack://_N_E/../../node_modules/lit-html/directives/repeat.js","webpack://_N_E/../../node_modules/lit/directives/repeat.js","webpack://_N_E/../../node_modules/lit-html/directives/style-map.js","webpack://_N_E/../../node_modules/lit/directives/style-map.js","webpack://_N_E/<anon>"],"sourcesContent":["import { Slot } from '@blocksuite/global/utils';\nexport class ActiveEditorManager {\n    constructor() {\n        this.activeSlot = new Slot();\n        this.clearActive = () => {\n            if (this.activeElement != undefined) {\n                this.activeElement = undefined;\n                this.activeSlot.emit(undefined);\n            }\n        };\n    }\n    isActive(ele) {\n        if (!this.activeElement) {\n            return false;\n        }\n        return this.activeElement.contains(ele);\n    }\n    setActive(ele) {\n        if (ele !== this.activeElement) {\n            this.activeElement = ele;\n            this.activeSlot.emit(ele);\n        }\n    }\n    setIfNoActive(ele) {\n        if (!this.activeElement) {\n            this.setActive(ele);\n        }\n    }\n    getActiveEditor() {\n        return this.activeElement;\n    }\n}\nexport const activeEditorManager = new ActiveEditorManager();\n//# sourceMappingURL=active-editor-manager.js.map","import { assertExists, } from '@blocksuite/store';\nimport { getDefaultPage, getModelByElement, getModelsByRange, getVirgoByModel, isInsidePageTitle, } from './query.js';\nimport { focusTitle, getCurrentNativeRange, hasNativeSelection, resetNativeSelection, } from './selection.js';\nexport function getCurrentBlockRange(page) {\n    // check exist block selection\n    const pageBlock = getDefaultPage(page);\n    if (pageBlock) {\n        const selectedBlocks = pageBlock.selection.state.selectedBlocks;\n        // Add embeds block to fix click image and delete case\n        const selectedEmbeds = pageBlock.selection.state.selectedEmbeds;\n        // Fix order may be wrong\n        const models = [...selectedBlocks, ...selectedEmbeds]\n            .map(element => getModelByElement(element))\n            .filter(Boolean);\n        if (models.length) {\n            return {\n                type: 'Block',\n                startOffset: 0,\n                endOffset: models[models.length - 1].text?.length ?? 0,\n                models,\n            };\n        }\n    }\n    // check exist native selection\n    if (hasNativeSelection()) {\n        const range = getCurrentNativeRange();\n        const blockRange = nativeRangeToBlockRange(range);\n        if (!blockRange) {\n            return null;\n        }\n        return { ...blockRange, nativeRange: range };\n    }\n    return null;\n}\nexport function blockRangeToNativeRange(blockRange) {\n    // special case for title\n    if (blockRange.type === 'Title') {\n        const page = blockRange.models[0].page;\n        const pageElement = getDefaultPage(page);\n        if (!pageElement) {\n            // Maybe in edgeless mode\n            return null;\n        }\n        const titleVEditor = pageElement.titleVEditor;\n        const [startNode, startOffset] = titleVEditor.getTextPoint(blockRange.startOffset);\n        const [endNode, endOffset] = titleVEditor.getTextPoint(blockRange.endOffset);\n        const range = new Range();\n        range.setStart(startNode, startOffset);\n        range.setEnd(endNode, endOffset);\n        return range;\n    }\n    const models = blockRange.models.filter(model => model.text);\n    if (!models.length) {\n        // BlockRange may be selected embeds, and it don't have text\n        // so we can't convert it to native range\n        return null;\n    }\n    const [startNode, startOffset] = getTextNodeByModel(models[0], blockRange.startOffset);\n    const [endNode, endOffset] = getTextNodeByModel(models[models.length - 1], blockRange.endOffset);\n    const range = new Range();\n    range.setStart(startNode, startOffset);\n    range.setEnd(endNode, endOffset);\n    return range;\n}\nexport function nativeRangeToBlockRange(range) {\n    // TODO check range is in page\n    const models = getModelsByRange(range);\n    if (!models.length) {\n        // NativeRange may be outside of the editor\n        // so we can't convert it to block range\n        return null;\n    }\n    const startVRange = getVRangeByNode(range.startContainer);\n    const endVRange = getVRangeByNode(range.endContainer);\n    if (!startVRange || !endVRange) {\n        return null;\n    }\n    const startOffset = startVRange.index;\n    const endOffset = endVRange.index + endVRange.length;\n    return {\n        type: 'Native',\n        startOffset,\n        endOffset,\n        models,\n    };\n}\n/**\n * Sometimes, the block in the block range is updated, we need to update the block range manually.\n *\n * Note: it will mutate the `blockRange` object.\n */\nexport function updateBlockRange(blockRange, oldModel, newModel) {\n    blockRange.models = blockRange.models.map(model => model === oldModel ? newModel : model);\n    return blockRange;\n}\n/**\n * Restore the block selection.\n * See also {@link resetNativeSelection}\n */\nexport function restoreSelection(blockRange) {\n    if (!blockRange.models.length) {\n        throw new Error(\"Can't restore selection, blockRange.models is empty\");\n    }\n    const page = blockRange.models[0].page;\n    const defaultPageBlock = getDefaultPage(page);\n    if (blockRange.type === 'Native') {\n        const range = blockRangeToNativeRange(blockRange);\n        resetNativeSelection(range);\n        // In the default mode\n        if (defaultPageBlock) {\n            defaultPageBlock.selection.state.clearBlockSelection();\n            defaultPageBlock.selection.state.type = 'native';\n        }\n        return;\n    }\n    if (blockRange.type === 'Block') {\n        // In the default mode\n        if (defaultPageBlock) {\n            defaultPageBlock.selection.state.type = 'block';\n            defaultPageBlock.selection.refreshSelectedBlocksRectsByModels(blockRange.models);\n        }\n        // Try clean native selection\n        resetNativeSelection(null);\n        document.activeElement.blur();\n        return;\n    }\n    // In the default mode\n    if (defaultPageBlock && blockRange.type === 'Title') {\n        focusTitle(page, blockRange.startOffset, blockRange.endOffset - blockRange.startOffset);\n        return;\n    }\n    throw new Error('Invalid block range type: ' + blockRange.type);\n}\n/**\n * Get the block range that includes the title range.\n *\n * In most cases, we should use {@link getCurrentBlockRange} to get current block range.\n *\n */\nexport function getExtendBlockRange(page) {\n    const basicBlockRange = getCurrentBlockRange(page);\n    if (basicBlockRange)\n        return basicBlockRange;\n    // Check title\n    if (!hasNativeSelection()) {\n        return null;\n    }\n    const range = getCurrentNativeRange();\n    const isTitleRange = isInsidePageTitle(range.startContainer) &&\n        isInsidePageTitle(range.endContainer);\n    if (isTitleRange) {\n        const pageModel = page.root;\n        assertExists(pageModel);\n        return {\n            type: 'Title',\n            startOffset: range.startOffset,\n            endOffset: range.endOffset,\n            models: [pageModel],\n        };\n    }\n    return null;\n}\nexport function getVRangeByNode(node) {\n    if (!node.parentElement)\n        return null;\n    const virgoElement = node.parentElement.closest('[data-virgo-root=\"true\"]') ||\n        (node instanceof HTMLElement\n            ? node.querySelector('[data-virgo-root=\"true\"]')\n            : null);\n    const vEditor = virgoElement?.virgoEditor;\n    if (!vEditor)\n        return null;\n    return vEditor.getVRange();\n}\n/**\n * Get the specific text node and offset by the selected block.\n * The reverse implementation of {@link getVRangeByNode}\n * See also {@link getVRangeByNode}\n *\n * ```ts\n * const [startNode, startOffset] = getTextNodeBySelectedBlock(startModel, startOffset);\n * const [endNode, endOffset] = getTextNodeBySelectedBlock(endModel, endOffset);\n *\n * const range = new Range();\n * range.setStart(startNode, startOffset);\n * range.setEnd(endNode, endOffset);\n *\n * const selection = window.getSelection();\n * selection.removeAllRanges();\n * selection.addRange(range);\n * ```\n */\nexport function getTextNodeByModel(model, offset = 0) {\n    const text = model.text;\n    if (!text) {\n        throw new Error(\"Failed to get block's text!\");\n    }\n    if (offset > text.length) {\n        offset = text.length;\n        // FIXME enable strict check\n        // console.error(\n        //   'Offset is out of range! model: ',\n        //   model,\n        //   'offset: ',\n        //   offset,\n        //   'text: ',\n        //   text.toString(),\n        //   'text.length: ',\n        //   text.length\n        // );\n    }\n    const vEditor = getVirgoByModel(model);\n    // TODO this assert is unreliable\n    assertExists(vEditor);\n    const [leaf, leafOffset] = vEditor.getTextPoint(offset);\n    return [leaf, leafOffset];\n}\nexport const experimentCreateBlockRange = (rangeOrBlockRange) => {\n    let cacheRange = rangeOrBlockRange instanceof Range ? rangeOrBlockRange : null;\n    const blockRange = rangeOrBlockRange instanceof Range\n        ? nativeRangeToBlockRange(rangeOrBlockRange)\n        : rangeOrBlockRange;\n    if (!blockRange) {\n        return null;\n    }\n    if (!blockRange.models.length) {\n        throw new Error('Block range must have at least one model.');\n    }\n    const getRange = () => {\n        // cache range may be expired\n        if (cacheRange) {\n            return cacheRange;\n        }\n        cacheRange = blockRangeToNativeRange(blockRange);\n        return cacheRange;\n    };\n    return {\n        ...blockRange,\n        startModel: blockRange.models[0],\n        endModel: blockRange.models[blockRange.models.length - 1],\n        betweenModels: blockRange.models.slice(1, blockRange.models.length - 1),\n        get range() {\n            return getRange();\n        },\n        collapsed: blockRange.models.length === 1 &&\n            blockRange.startOffset === blockRange.endOffset,\n        apply() {\n            restoreSelection(blockRange);\n        },\n    };\n};\n//# sourceMappingURL=block-range.js.map","import { assertExists, matchFlavours } from '@blocksuite/global/utils';\nimport { asyncGetRichTextByModel, getBlockElementByModel, getVirgoByModel, } from './query.js';\nexport async function asyncSetVRange(model, vRange) {\n    const richText = await asyncGetRichTextByModel(model);\n    richText?.vEditor?.setVRange(vRange);\n    return new Promise(resolve => {\n        richText?.vEditor?.slots.rangeUpdated.once(() => {\n            resolve();\n        });\n    });\n}\nexport function asyncFocusRichText(page, id, vRange = { index: 0, length: 0 }) {\n    const model = page.getBlockById(id);\n    assertExists(model);\n    if (matchFlavours(model, ['affine:divider']))\n        return;\n    return asyncSetVRange(model, vRange);\n}\nexport function isCollapsedAtBlockStart(vEditor) {\n    const vRange = vEditor.getVRange();\n    return vRange?.index === 0 && vRange?.length === 0;\n}\nexport function isInSamePath(page, children, father) {\n    if (children === father) {\n        return true;\n    }\n    let parent;\n    for (;;) {\n        parent = page.getParent(children);\n        if (parent === null) {\n            return false;\n        }\n        else if (parent.id === father.id) {\n            return true;\n        }\n        children = parent;\n    }\n}\nexport function convertToList(page, model, listType, prefix, otherProperties) {\n    if (matchFlavours(model, ['affine:list']) && model['type'] === listType) {\n        return false;\n    }\n    if (matchFlavours(model, ['affine:paragraph'])) {\n        const parent = page.getParent(model);\n        if (!parent)\n            return false;\n        const index = parent.children.indexOf(model);\n        model.text?.insert(' ', prefix.length);\n        page.captureSync();\n        model.text?.delete(0, prefix.length + 1);\n        const blockProps = {\n            type: listType,\n            text: model.text?.clone(),\n            children: model.children,\n            ...otherProperties,\n        };\n        page.deleteBlock(model);\n        const id = page.addBlock('affine:list', blockProps, parent, index);\n        asyncFocusRichText(page, id);\n    }\n    else if (matchFlavours(model, ['affine:list']) &&\n        model['type'] !== listType) {\n        model.text?.insert(' ', prefix.length);\n        page.captureSync();\n        model.text?.delete(0, prefix.length + 1);\n        page.updateBlock(model, { type: listType });\n        asyncFocusRichText(page, model.id);\n    }\n    return true;\n}\nexport function convertToParagraph(page, model, type, prefix) {\n    if (matchFlavours(model, ['affine:paragraph']) && model['type'] === type) {\n        return false;\n    }\n    if (!matchFlavours(model, ['affine:paragraph'])) {\n        const parent = page.getParent(model);\n        if (!parent)\n            return false;\n        const index = parent.children.indexOf(model);\n        model.text?.insert(' ', prefix.length);\n        page.captureSync();\n        model.text?.delete(0, prefix.length + 1);\n        const blockProps = {\n            type: type,\n            text: model.text?.clone(),\n            children: model.children,\n        };\n        page.deleteBlock(model);\n        const id = page.addBlock('affine:paragraph', blockProps, parent, index);\n        asyncFocusRichText(page, id);\n    }\n    else if (matchFlavours(model, ['affine:paragraph']) &&\n        model['type'] !== type) {\n        model.text?.insert(' ', prefix.length);\n        page.captureSync();\n        model.text?.delete(0, prefix.length + 1);\n        const vEditor = getVirgoByModel(model);\n        if (vEditor) {\n            vEditor.setVRange({\n                index: 0,\n                length: 0,\n            });\n        }\n        page.updateBlock(model, { type: type });\n    }\n    return true;\n}\nexport function convertToDivider(page, model, prefix) {\n    if (matchFlavours(model, ['affine:divider']) || model.type === 'quote') {\n        return false;\n    }\n    if (!matchFlavours(model, ['affine:divider'])) {\n        const parent = page.getParent(model);\n        if (!parent)\n            return false;\n        const index = parent.children.indexOf(model);\n        model.text?.insert(' ', prefix.length);\n        page.captureSync();\n        model.text?.delete(0, prefix.length + 1);\n        const blockProps = {\n            children: model.children,\n        };\n        // space.deleteBlock(model);\n        page.addBlock('affine:divider', blockProps, parent, index);\n        const nextBlock = parent.children[index + 1];\n        if (nextBlock) {\n            asyncFocusRichText(page, nextBlock.id);\n        }\n        else {\n            const nextId = page.addBlock('affine:paragraph', {}, parent);\n            asyncFocusRichText(page, nextId);\n        }\n    }\n    return true;\n}\nexport function createBookmarkBlock(parentModel, index) {\n    const { page } = parentModel;\n    const id = page.addBlock('affine:bookmark', { url: '' }, parentModel.id, index);\n    requestAnimationFrame(() => {\n        const model = page.getBlockById(id);\n        const element = getBlockElementByModel(model);\n        element.slots.openInitialModal.emit();\n    });\n    return id;\n}\n//# sourceMappingURL=common-operations.js.map","import { assertExists } from '@blocksuite/global/utils';\nexport const createImageInputElement = () => {\n    const fileInput = document.createElement('input');\n    fileInput.type = 'file';\n    fileInput.multiple = true;\n    fileInput.accept = 'image/*';\n    fileInput.style.position = 'fixed';\n    fileInput.style.left = '0';\n    fileInput.style.top = '0';\n    fileInput.style.opacity = '0.001';\n    return fileInput;\n};\nexport const uploadImageFromLocal = async (page, getSize) => {\n    const baseProps = { flavour: 'affine:embed', type: 'image' };\n    const fileInput = createImageInputElement();\n    document.body.appendChild(fileInput);\n    let resolvePromise;\n    const pending = new Promise(resolve => {\n        resolvePromise = resolve;\n    });\n    const onChange = async () => {\n        if (!fileInput.files)\n            return;\n        const storage = await page.blobs;\n        assertExists(storage);\n        const files = fileInput.files;\n        if (files.length === 1) {\n            const file = files[0];\n            if (getSize) {\n                getSize(await readImageSize(file));\n            }\n            const id = await storage.set(file);\n            resolvePromise([{ ...baseProps, sourceId: id }]);\n        }\n        else {\n            const res = [];\n            for (let i = 0; i < files.length; i++) {\n                const file = files[i];\n                const id = await storage.set(file);\n                res.push({ ...baseProps, sourceId: id });\n            }\n            resolvePromise(res);\n        }\n        fileInput.removeEventListener('change', onChange);\n        fileInput.remove();\n    };\n    fileInput.addEventListener('change', onChange);\n    fileInput.click();\n    return await pending;\n};\nfunction readImageSize(file) {\n    return new Promise(resolve => {\n        let width = 0;\n        let height = 0;\n        let reader = new FileReader();\n        reader.addEventListener('load', _ => {\n            const img = new Image();\n            img.onload = () => {\n                width = img.width;\n                height = img.height;\n                reader = null;\n                resolve({ width, height });\n            };\n            img.src = reader?.result;\n        });\n        reader.addEventListener('error', _ => {\n            reader = null;\n            resolve({ width, height });\n        });\n        reader.readAsDataURL(file);\n    });\n}\n//# sourceMappingURL=filesys.js.map","/**! \n * hotkeys-js v3.10.2 \n * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies. \n * \n * Copyright (c) 2023 kenny wong <wowohoo@qq.com> \n * http://jaywcjlove.github.io/hotkeys \n * Licensed under the MIT license \n */\n\nvar isff = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase().indexOf('firefox') > 0 : false; // 绑定事件\n\nfunction addEvent(object, event, method, useCapture) {\n  if (object.addEventListener) {\n    object.addEventListener(event, method, useCapture);\n  } else if (object.attachEvent) {\n    object.attachEvent(\"on\".concat(event), function () {\n      method(window.event);\n    });\n  }\n} // 修饰键转换成对应的键码\n\n\nfunction getMods(modifier, key) {\n  var mods = key.slice(0, key.length - 1);\n\n  for (var i = 0; i < mods.length; i++) {\n    mods[i] = modifier[mods[i].toLowerCase()];\n  }\n\n  return mods;\n} // 处理传的key字符串转换成数组\n\n\nfunction getKeys(key) {\n  if (typeof key !== 'string') key = '';\n  key = key.replace(/\\s/g, ''); // 匹配任何空白字符,包括空格、制表符、换页符等等\n\n  var keys = key.split(','); // 同时设置多个快捷键，以','分割\n\n  var index = keys.lastIndexOf(''); // 快捷键可能包含','，需特殊处理\n\n  for (; index >= 0;) {\n    keys[index - 1] += ',';\n    keys.splice(index, 1);\n    index = keys.lastIndexOf('');\n  }\n\n  return keys;\n} // 比较修饰键的数组\n\n\nfunction compareArray(a1, a2) {\n  var arr1 = a1.length >= a2.length ? a1 : a2;\n  var arr2 = a1.length >= a2.length ? a2 : a1;\n  var isIndex = true;\n\n  for (var i = 0; i < arr1.length; i++) {\n    if (arr2.indexOf(arr1[i]) === -1) isIndex = false;\n  }\n\n  return isIndex;\n}\n\nvar _keyMap = {\n  backspace: 8,\n  '⌫': 8,\n  tab: 9,\n  clear: 12,\n  enter: 13,\n  '↩': 13,\n  return: 13,\n  esc: 27,\n  escape: 27,\n  space: 32,\n  left: 37,\n  up: 38,\n  right: 39,\n  down: 40,\n  del: 46,\n  delete: 46,\n  ins: 45,\n  insert: 45,\n  home: 36,\n  end: 35,\n  pageup: 33,\n  pagedown: 34,\n  capslock: 20,\n  num_0: 96,\n  num_1: 97,\n  num_2: 98,\n  num_3: 99,\n  num_4: 100,\n  num_5: 101,\n  num_6: 102,\n  num_7: 103,\n  num_8: 104,\n  num_9: 105,\n  num_multiply: 106,\n  num_add: 107,\n  num_enter: 108,\n  num_subtract: 109,\n  num_decimal: 110,\n  num_divide: 111,\n  '⇪': 20,\n  ',': 188,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '-': isff ? 173 : 189,\n  '=': isff ? 61 : 187,\n  ';': isff ? 59 : 186,\n  '\\'': 222,\n  '[': 219,\n  ']': 221,\n  '\\\\': 220\n}; // Modifier Keys\n\nvar _modifier = {\n  // shiftKey\n  '⇧': 16,\n  shift: 16,\n  // altKey\n  '⌥': 18,\n  alt: 18,\n  option: 18,\n  // ctrlKey\n  '⌃': 17,\n  ctrl: 17,\n  control: 17,\n  // metaKey\n  '⌘': 91,\n  cmd: 91,\n  command: 91\n};\nvar modifierMap = {\n  16: 'shiftKey',\n  18: 'altKey',\n  17: 'ctrlKey',\n  91: 'metaKey',\n  shiftKey: 16,\n  ctrlKey: 17,\n  altKey: 18,\n  metaKey: 91\n};\nvar _mods = {\n  16: false,\n  18: false,\n  17: false,\n  91: false\n};\nvar _handlers = {}; // F1~F12 special key\n\nfor (var k = 1; k < 20; k++) {\n  _keyMap[\"f\".concat(k)] = 111 + k;\n}\n\nvar _downKeys = []; // 记录摁下的绑定键\n\nvar winListendFocus = false; // window是否已经监听了focus事件\n\nvar _scope = 'all'; // 默认热键范围\n\nvar elementHasBindEvent = []; // 已绑定事件的节点记录\n// 返回键码\n\nvar code = function code(x) {\n  return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);\n};\n\nvar getKey = function getKey(x) {\n  return Object.keys(_keyMap).find(function (k) {\n    return _keyMap[k] === x;\n  });\n};\n\nvar getModifier = function getModifier(x) {\n  return Object.keys(_modifier).find(function (k) {\n    return _modifier[k] === x;\n  });\n}; // 设置获取当前范围（默认为'所有'）\n\n\nfunction setScope(scope) {\n  _scope = scope || 'all';\n} // 获取当前范围\n\n\nfunction getScope() {\n  return _scope || 'all';\n} // 获取摁下绑定键的键值\n\n\nfunction getPressedKeyCodes() {\n  return _downKeys.slice(0);\n}\n\nfunction getPressedKeyString() {\n  return _downKeys.map(function (c) {\n    return getKey(c) || getModifier(c) || String.fromCharCode(c);\n  });\n} // 表单控件控件判断 返回 Boolean\n// hotkey is effective only when filter return true\n\n\nfunction filter(event) {\n  var target = event.target || event.srcElement;\n  var tagName = target.tagName;\n  var flag = true; // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>\n\n  if (target.isContentEditable || (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') && !target.readOnly) {\n    flag = false;\n  }\n\n  return flag;\n} // 判断摁下的键是否为某个键，返回true或者false\n\n\nfunction isPressed(keyCode) {\n  if (typeof keyCode === 'string') {\n    keyCode = code(keyCode); // 转换成键码\n  }\n\n  return _downKeys.indexOf(keyCode) !== -1;\n} // 循环删除handlers中的所有 scope(范围)\n\n\nfunction deleteScope(scope, newScope) {\n  var handlers;\n  var i; // 没有指定scope，获取scope\n\n  if (!scope) scope = getScope();\n\n  for (var key in _handlers) {\n    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {\n      handlers = _handlers[key];\n\n      for (i = 0; i < handlers.length;) {\n        if (handlers[i].scope === scope) handlers.splice(i, 1);else i++;\n      }\n    }\n  } // 如果scope被删除，将scope重置为all\n\n\n  if (getScope() === scope) setScope(newScope || 'all');\n} // 清除修饰键\n\n\nfunction clearModifier(event) {\n  var key = event.keyCode || event.which || event.charCode;\n\n  var i = _downKeys.indexOf(key); // 从列表中清除按压过的键\n\n\n  if (i >= 0) {\n    _downKeys.splice(i, 1);\n  } // 特殊处理 cmmand 键，在 cmmand 组合快捷键 keyup 只执行一次的问题\n\n\n  if (event.key && event.key.toLowerCase() === 'meta') {\n    _downKeys.splice(0, _downKeys.length);\n  } // 修饰键 shiftKey altKey ctrlKey (command||metaKey) 清除\n\n\n  if (key === 93 || key === 224) key = 91;\n\n  if (key in _mods) {\n    _mods[key] = false; // 将修饰键重置为false\n\n    for (var k in _modifier) {\n      if (_modifier[k] === key) hotkeys[k] = false;\n    }\n  }\n}\n\nfunction unbind(keysInfo) {\n  // unbind(), unbind all keys\n  if (typeof keysInfo === 'undefined') {\n    Object.keys(_handlers).forEach(function (key) {\n      return delete _handlers[key];\n    });\n  } else if (Array.isArray(keysInfo)) {\n    // support like : unbind([{key: 'ctrl+a', scope: 's1'}, {key: 'ctrl-a', scope: 's2', splitKey: '-'}])\n    keysInfo.forEach(function (info) {\n      if (info.key) eachUnbind(info);\n    });\n  } else if (typeof keysInfo === 'object') {\n    // support like unbind({key: 'ctrl+a, ctrl+b', scope:'abc'})\n    if (keysInfo.key) eachUnbind(keysInfo);\n  } else if (typeof keysInfo === 'string') {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    // support old method\n    // eslint-disable-line\n    var scope = args[0],\n        method = args[1];\n\n    if (typeof scope === 'function') {\n      method = scope;\n      scope = '';\n    }\n\n    eachUnbind({\n      key: keysInfo,\n      scope: scope,\n      method: method,\n      splitKey: '+'\n    });\n  }\n} // 解除绑定某个范围的快捷键\n\n\nvar eachUnbind = function eachUnbind(_ref) {\n  var key = _ref.key,\n      scope = _ref.scope,\n      method = _ref.method,\n      _ref$splitKey = _ref.splitKey,\n      splitKey = _ref$splitKey === void 0 ? '+' : _ref$splitKey;\n  var multipleKeys = getKeys(key);\n  multipleKeys.forEach(function (originKey) {\n    var unbindKeys = originKey.split(splitKey);\n    var len = unbindKeys.length;\n    var lastKey = unbindKeys[len - 1];\n    var keyCode = lastKey === '*' ? '*' : code(lastKey);\n    if (!_handlers[keyCode]) return; // 判断是否传入范围，没有就获取范围\n\n    if (!scope) scope = getScope();\n    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];\n    _handlers[keyCode] = _handlers[keyCode].filter(function (record) {\n      // 通过函数判断，是否解除绑定，函数相等直接返回\n      var isMatchingMethod = method ? record.method === method : true;\n      return !(isMatchingMethod && record.scope === scope && compareArray(record.mods, mods));\n    });\n  });\n}; // 对监听对应快捷键的回调函数进行处理\n\n\nfunction eventHandler(event, handler, scope, element) {\n  if (handler.element !== element) {\n    return;\n  }\n\n  var modifiersMatch; // 看它是否在当前范围\n\n  if (handler.scope === scope || handler.scope === 'all') {\n    // 检查是否匹配修饰符（如果有返回true）\n    modifiersMatch = handler.mods.length > 0;\n\n    for (var y in _mods) {\n      if (Object.prototype.hasOwnProperty.call(_mods, y)) {\n        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {\n          modifiersMatch = false;\n        }\n      }\n    } // 调用处理程序，如果是修饰键不做处理\n\n\n    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === '*') {\n      if (handler.method(event, handler) === false) {\n        if (event.preventDefault) event.preventDefault();else event.returnValue = false;\n        if (event.stopPropagation) event.stopPropagation();\n        if (event.cancelBubble) event.cancelBubble = true;\n      }\n    }\n  }\n} // 处理keydown事件\n\n\nfunction dispatch(event, element) {\n  var asterisk = _handlers['*'];\n  var key = event.keyCode || event.which || event.charCode; // 表单控件过滤 默认表单控件不触发快捷键\n\n  if (!hotkeys.filter.call(this, event)) return; // Gecko(Firefox)的command键值224，在Webkit(Chrome)中保持一致\n  // Webkit左右 command 键值不一样\n\n  if (key === 93 || key === 224) key = 91;\n  /**\n   * Collect bound keys\n   * If an Input Method Editor is processing key input and the event is keydown, return 229.\n   * https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229\n   * http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n   */\n\n  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);\n  /**\n   * Jest test cases are required.\n   * ===============================\n   */\n\n  ['ctrlKey', 'altKey', 'shiftKey', 'metaKey'].forEach(function (keyName) {\n    var keyNum = modifierMap[keyName];\n\n    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {\n      _downKeys.push(keyNum);\n    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {\n      _downKeys.splice(_downKeys.indexOf(keyNum), 1);\n    } else if (keyName === 'metaKey' && event[keyName] && _downKeys.length === 3) {\n      /**\n       * Fix if Command is pressed:\n       * ===============================\n       */\n      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {\n        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));\n      }\n    }\n  });\n  /**\n   * -------------------------------\n   */\n\n  if (key in _mods) {\n    _mods[key] = true; // 将特殊字符的key注册到 hotkeys 上\n\n    for (var k in _modifier) {\n      if (_modifier[k] === key) hotkeys[k] = true;\n    }\n\n    if (!asterisk) return;\n  } // 将 modifierMap 里面的修饰键绑定到 event 中\n\n\n  for (var e in _mods) {\n    if (Object.prototype.hasOwnProperty.call(_mods, e)) {\n      _mods[e] = event[modifierMap[e]];\n    }\n  }\n  /**\n   * https://github.com/jaywcjlove/hotkeys/pull/129\n   * This solves the issue in Firefox on Windows where hotkeys corresponding to special characters would not trigger.\n   * An example of this is ctrl+alt+m on a Swedish keyboard which is used to type μ.\n   * Browser support: https://caniuse.com/#feat=keyboardevent-getmodifierstate\n   */\n\n\n  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState('AltGraph')) {\n    if (_downKeys.indexOf(17) === -1) {\n      _downKeys.push(17);\n    }\n\n    if (_downKeys.indexOf(18) === -1) {\n      _downKeys.push(18);\n    }\n\n    _mods[17] = true;\n    _mods[18] = true;\n  } // 获取范围 默认为 `all`\n\n\n  var scope = getScope(); // 对任何快捷键都需要做的处理\n\n  if (asterisk) {\n    for (var i = 0; i < asterisk.length; i++) {\n      if (asterisk[i].scope === scope && (event.type === 'keydown' && asterisk[i].keydown || event.type === 'keyup' && asterisk[i].keyup)) {\n        eventHandler(event, asterisk[i], scope, element);\n      }\n    }\n  } // key 不在 _handlers 中返回\n\n\n  if (!(key in _handlers)) return;\n\n  for (var _i = 0; _i < _handlers[key].length; _i++) {\n    if (event.type === 'keydown' && _handlers[key][_i].keydown || event.type === 'keyup' && _handlers[key][_i].keyup) {\n      if (_handlers[key][_i].key) {\n        var record = _handlers[key][_i];\n        var splitKey = record.splitKey;\n        var keyShortcut = record.key.split(splitKey);\n        var _downKeysCurrent = []; // 记录当前按键键值\n\n        for (var a = 0; a < keyShortcut.length; a++) {\n          _downKeysCurrent.push(code(keyShortcut[a]));\n        }\n\n        if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) {\n          // 找到处理内容\n          eventHandler(event, record, scope, element);\n        }\n      }\n    }\n  }\n} // 判断 element 是否已经绑定事件\n\n\nfunction isElementBind(element) {\n  return elementHasBindEvent.indexOf(element) > -1;\n}\n\nfunction hotkeys(key, option, method) {\n  _downKeys = [];\n  var keys = getKeys(key); // 需要处理的快捷键列表\n\n  var mods = [];\n  var scope = 'all'; // scope默认为all，所有范围都有效\n\n  var element = document; // 快捷键事件绑定节点\n\n  var i = 0;\n  var keyup = false;\n  var keydown = true;\n  var splitKey = '+';\n  var capture = false; // 对为设定范围的判断\n\n  if (method === undefined && typeof option === 'function') {\n    method = option;\n  }\n\n  if (Object.prototype.toString.call(option) === '[object Object]') {\n    if (option.scope) scope = option.scope; // eslint-disable-line\n\n    if (option.element) element = option.element; // eslint-disable-line\n\n    if (option.keyup) keyup = option.keyup; // eslint-disable-line\n\n    if (option.keydown !== undefined) keydown = option.keydown; // eslint-disable-line\n\n    if (option.capture !== undefined) capture = option.capture; // eslint-disable-line\n\n    if (typeof option.splitKey === 'string') splitKey = option.splitKey; // eslint-disable-line\n  }\n\n  if (typeof option === 'string') scope = option; // 对于每个快捷键进行处理\n\n  for (; i < keys.length; i++) {\n    key = keys[i].split(splitKey); // 按键列表\n\n    mods = []; // 如果是组合快捷键取得组合快捷键\n\n    if (key.length > 1) mods = getMods(_modifier, key); // 将非修饰键转化为键码\n\n    key = key[key.length - 1];\n    key = key === '*' ? '*' : code(key); // *表示匹配所有快捷键\n    // 判断key是否在_handlers中，不在就赋一个空数组\n\n    if (!(key in _handlers)) _handlers[key] = [];\n\n    _handlers[key].push({\n      keyup: keyup,\n      keydown: keydown,\n      scope: scope,\n      mods: mods,\n      shortcut: keys[i],\n      method: method,\n      key: keys[i],\n      splitKey: splitKey,\n      element: element\n    });\n  } // 在全局document上设置快捷键\n\n\n  if (typeof element !== 'undefined' && !isElementBind(element) && window) {\n    elementHasBindEvent.push(element);\n    addEvent(element, 'keydown', function (e) {\n      dispatch(e, element);\n    }, capture);\n\n    if (!winListendFocus) {\n      winListendFocus = true;\n      addEvent(window, 'focus', function () {\n        _downKeys = [];\n      }, capture);\n    }\n\n    addEvent(element, 'keyup', function (e) {\n      dispatch(e, element);\n      clearModifier(e);\n    }, capture);\n  }\n}\n\nfunction trigger(shortcut) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';\n  Object.keys(_handlers).forEach(function (key) {\n    var dataList = _handlers[key].filter(function (item) {\n      return item.scope === scope && item.shortcut === shortcut;\n    });\n\n    dataList.forEach(function (data) {\n      if (data && data.method) {\n        data.method();\n      }\n    });\n  });\n}\n\nvar _api = {\n  getPressedKeyString: getPressedKeyString,\n  setScope: setScope,\n  getScope: getScope,\n  deleteScope: deleteScope,\n  getPressedKeyCodes: getPressedKeyCodes,\n  isPressed: isPressed,\n  filter: filter,\n  trigger: trigger,\n  unbind: unbind,\n  keyMap: _keyMap,\n  modifier: _modifier,\n  modifierMap: modifierMap\n};\n\nfor (var a in _api) {\n  if (Object.prototype.hasOwnProperty.call(_api, a)) {\n    hotkeys[a] = _api[a];\n  }\n}\n\nif (typeof window !== 'undefined') {\n  var _hotkeys = window.hotkeys;\n\n  hotkeys.noConflict = function (deep) {\n    if (deep && window.hotkeys === hotkeys) {\n      window.hotkeys = _hotkeys;\n    }\n\n    return hotkeys;\n  };\n\n  window.hotkeys = hotkeys;\n}\n\nexport { hotkeys as default };\n","import hotkeys from 'hotkeys-js';\nimport { isCaptionElement, isDatabaseInput, isInsideDatabaseTitle, isInsideEdgelessTextEditor, isInsidePageTitle, isInsideRichText, } from './query.js';\nhotkeys.filter = (event) => {\n    if (shouldFilterHotkey(event))\n        return false;\n    return true;\n};\nfunction isUndoRedo(event) {\n    // If undo or redo: when event.shiftKey is false => undo, when event.shiftKey is true => redo\n    if ((event.ctrlKey || event.metaKey) && !event.altKey && event.key === 'z') {\n        return true;\n    }\n    return false;\n}\n/**\n * Return `true` if the event should be ignore.\n */\nfunction shouldFilterHotkey(event) {\n    const target = event.target;\n    // Not sure if this is the right thing to do\n    if (!target) {\n        return true;\n    }\n    // Skip input element\n    // including\n    // - code block language search input\n    // - image caption\n    // - link create/edit popover\n    if (!isInsideRichText(event.target)) {\n        // TODO Remove ad-hoc\n        // This ad-hoc should be moved to the caption input for processing\n        // Enter on caption should jump out of input\n        // See also `hotkey.addListener(ENTER, handler)`\n        if (isCaptionElement(event.target) && event.key === 'Enter') {\n            return false;\n        }\n        // undo/redo should work in page title\n        if (isInsidePageTitle(event.target) && isUndoRedo(event)) {\n            return false;\n        }\n        // undo/redo should work in database title or cell container\n        if ((isInsideDatabaseTitle(event.target) || isDatabaseInput(event.target)) &&\n            isUndoRedo(event)) {\n            return false;\n        }\n        // undo/redo should work in edgeless text editor\n        if (isInsideEdgelessTextEditor(event.target) && isUndoRedo(event)) {\n            return false;\n        }\n        // Some event dispatch from body\n        // for example, press backspace to remove block-level selection\n        if (event.target === document.body) {\n            // TODO filter arrow key\n            return false;\n        }\n        return true;\n    }\n    // if (\n    //   target instanceof Element &&\n    //   ['INPUT', 'EDIT-LINK-PANEL'].includes(target.tagName)\n    // ) {\n    //   return true;\n    // }\n    return false;\n}\nexport const HOTKEY_SCOPE_TYPE = {\n    AFFINE_PAGE: 'affine:page',\n    AFFINE_EDGELESS: 'affine:edgeless',\n};\nconst HOTKEY_DISABLED_SCOPE = 'hotkey_disabled';\n/**\n * Singleton\n *\n * When rendering a page or an edgeless view,\n * `setScope` is called to set a unique scope for each view.\n * All hotkeys are then bound to this scope.\n * When a page or an edgeless view is disconnected,\n * all hotkeys registered during the view's lifetime are destroyed.\n */\nclass HotkeyManager {\n    constructor() {\n        this._scope = HOTKEY_DISABLED_SCOPE;\n        this._disabled = false;\n        this.counter = 0;\n        this._hotkeys = hotkeys;\n    }\n    get disabled() {\n        return this._disabled;\n    }\n    newScope(type) {\n        return `${type}-${this.counter++}`;\n    }\n    setScope(scope) {\n        this._scope = scope;\n        this._hotkeys.setScope(scope);\n    }\n    deleteScope(scope) {\n        this._hotkeys.deleteScope(scope);\n    }\n    addListener(hotkey, listener, options = {}) {\n        this._hotkeys(hotkey, { ...options, scope: this._scope }, listener);\n    }\n    removeListener(hotkey) {\n        this._hotkeys.unbind((Array.isArray(hotkey) ? hotkey : [hotkey]).join(','), this._scope);\n    }\n    disableHotkey() {\n        this._disabled = true;\n        this._hotkeys.setScope(HOTKEY_DISABLED_SCOPE);\n    }\n    enableHotkey() {\n        this._disabled = false;\n        this._hotkeys.setScope(this._scope);\n    }\n    /**\n     * Create a context to shielding against global hotkey.\n     *\n     * The param `fn` will be executed immediately.\n     * @example\n     * ```ts\n     * const ret = await hotkey.withDisableHotkey(async () => {\n     *   const result = await createLink(space);\n     *   return result;\n     * });\n     * ```\n     */\n    async withDisabledHotkey(fn) {\n        this.disableHotkey();\n        try {\n            return await fn();\n        }\n        finally {\n            this.enableHotkey();\n        }\n    }\n    /**\n     * Similar to {@link withDisableHotkey}, but return a function instead of execute immediately.\n     * @example\n     * ```ts\n     * const createLinkWithoutHotkey = withDisabledHotkeyFn((space) => createLink(space));\n     * await createLinkWithoutHotkey(space);\n     * ```\n     */\n    withDisabledHotkeyFn(fn) {\n        return ((...args) => this.withDisabledHotkey(() => fn(...args)));\n    }\n    withScope(scope, fn) {\n        const pre = this._scope;\n        try {\n            this._scope = scope;\n            fn();\n        }\n        finally {\n            this._scope = pre;\n        }\n    }\n}\nexport const hotkey = new HotkeyManager();\n//# sourceMappingURL=hotkey.js.map","import { assertExists, matchFlavours } from '@blocksuite/global/utils';\nimport { DropFlags, getClosestBlockElementByElement, getDropRectByPoint, getModelByBlockElement, getRectByBlockElement, } from './query.js';\nimport { Rect } from './rect.js';\nimport {} from './types.js';\n/**\n * Calculates the drop target.\n */\nexport function calcDropTarget(point, model, element, draggingElements, scale, flavour = null // for block-hub\n) {\n    const schema = model.page.getSchemaByFlavour('affine:database');\n    assertExists(schema);\n    const children = schema.model.children ?? [];\n    let shouldAppendToDatabase = true;\n    if (children.length) {\n        if (draggingElements.length) {\n            shouldAppendToDatabase = draggingElements\n                .map(getModelByBlockElement)\n                .every(m => children.includes(m.flavour));\n        }\n        else if (flavour) {\n            shouldAppendToDatabase = children.includes(flavour);\n        }\n    }\n    if (!shouldAppendToDatabase && !matchFlavours(model, ['affine:database'])) {\n        const databaseBlockElement = element.closest('affine-database');\n        if (databaseBlockElement) {\n            element = databaseBlockElement;\n            model = getModelByBlockElement(element);\n        }\n    }\n    let type = 'none';\n    const height = 3 * scale;\n    const { rect: domRect, flag } = getDropRectByPoint(point, model, element);\n    if (flag === DropFlags.EmptyDatabase) {\n        // empty database\n        const rect = Rect.fromDOMRect(domRect);\n        rect.top -= height / 2;\n        rect.height = height;\n        type = 'database';\n        return {\n            type,\n            rect,\n            modelState: {\n                model,\n                rect: domRect,\n                element: element,\n            },\n        };\n    }\n    else if (flag === DropFlags.Database) {\n        // not empty database\n        const distanceToTop = Math.abs(domRect.top - point.y);\n        const distanceToBottom = Math.abs(domRect.bottom - point.y);\n        const before = distanceToTop < distanceToBottom;\n        type = before ? 'before' : 'after';\n        return {\n            type,\n            rect: Rect.fromLWTH(domRect.left, domRect.width, (before ? domRect.top - 1 : domRect.bottom) - height / 2, height),\n            modelState: {\n                model,\n                rect: domRect,\n                element: element,\n            },\n        };\n    }\n    const distanceToTop = Math.abs(domRect.top - point.y);\n    const distanceToBottom = Math.abs(domRect.bottom - point.y);\n    const before = distanceToTop < distanceToBottom;\n    type = before ? 'before' : 'after';\n    let offsetY = 4;\n    if (type === 'before') {\n        // before\n        let prev;\n        let prevRect;\n        prev = element.previousElementSibling;\n        if (prev) {\n            if (prev === draggingElements[draggingElements.length - 1]) {\n                type = 'none';\n            }\n            else {\n                prevRect = getRectByBlockElement(prev);\n            }\n        }\n        else {\n            prev = element.parentElement?.previousElementSibling;\n            if (prev) {\n                prevRect = prev.getBoundingClientRect();\n            }\n        }\n        if (prevRect) {\n            offsetY = (domRect.top - prevRect.bottom) / 2;\n        }\n    }\n    else {\n        // after\n        let next;\n        let nextRect;\n        next = element.nextElementSibling;\n        if (next) {\n            if (next === draggingElements[0]) {\n                type = 'none';\n                next = null;\n            }\n        }\n        else {\n            next = getClosestBlockElementByElement(element.parentElement)?.nextElementSibling;\n        }\n        if (next) {\n            nextRect = getRectByBlockElement(next);\n            offsetY = (nextRect.top - domRect.bottom) / 2;\n        }\n    }\n    if (type === 'none')\n        return null;\n    let top = domRect.top;\n    if (type === 'before') {\n        top -= offsetY;\n    }\n    else {\n        top += domRect.height + offsetY;\n    }\n    return {\n        type,\n        rect: Rect.fromLWTH(domRect.left, domRect.width, top - height / 2, height),\n        modelState: {\n            model,\n            rect: domRect,\n            element: element,\n        },\n    };\n}\n//# sourceMappingURL=drag-and-drop.js.map","import { IS_IOS, IS_MAC } from '@blocksuite/global/config';\nexport function isPinchEvent(e) {\n    // two finger pinches on touch pad, ctrlKey is always true.\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=397027\n    if (IS_IOS || IS_MAC) {\n        return e.ctrlKey || e.metaKey;\n    }\n    return e.ctrlKey;\n}\n/**\n * Returns a `DragEvent` via `MouseEvent`.\n */\nexport function createDragEvent(type, event) {\n    const options = {\n        dataTransfer: new DataTransfer(),\n    };\n    if (event) {\n        const { clientX, clientY, screenX, screenY } = event;\n        Object.assign(options, {\n            clientX,\n            clientY,\n            screenX,\n            screenY,\n        });\n    }\n    return new DragEvent(type, options);\n}\n//# sourceMappingURL=event.js.map","// Reorders the shapes or frames.\n/**\n * Gets indexes of a from b.\n */\nexport function getIndexesWith(a, b) {\n    return a.map(e => b.findIndex(element => element === e));\n}\n/**\n * Generates the ranges via indexes;\n */\nexport function generateRanges(indexes) {\n    let curr;\n    let i = 1;\n    let start = indexes[0];\n    let end = indexes[0];\n    const ranges = [{ start, end }];\n    const len = indexes.length;\n    for (; i < len; i++) {\n        curr = indexes[i];\n        if (curr - end === 1) {\n            ranges[ranges.length - 1].end = end = curr;\n        }\n        else {\n            start = end = curr;\n            ranges.push({ start, end });\n        }\n    }\n    return ranges;\n}\n/**\n * Reorders the elements, moving multiple ranges of child elements to the end.\n */\nexport function bringToFront(ranges, elements) {\n    let n = 0;\n    let i = ranges.length;\n    const t = elements.length;\n    while (i) {\n        i--;\n        const { start, end } = ranges[i];\n        const temp = elements.splice(start, end + 1 - start);\n        n += temp.length;\n        elements.splice(t - n, 0, ...temp);\n    }\n}\n/**\n * Reorders the elements, moving multiple ranges of child elements forward.\n */\nexport function bringForward(ranges, elements) {\n    let i = ranges.length;\n    while (i) {\n        i--;\n        const { start, end } = ranges[i];\n        const temp = elements.splice(start, end + 1 - start);\n        elements.splice(start + 1, 0, ...temp);\n    }\n}\n/**\n * Reorders the elements, moving multiple ranges of child elements backward.\n */\nexport function sendBackward(ranges, elements) {\n    let i = 0;\n    const len = ranges.length;\n    for (; i < len; i++) {\n        const { start, end } = ranges[i];\n        if (start === 0)\n            continue;\n        const temp = elements.splice(start, end + 1 - start);\n        elements.splice(start - 1, 0, ...temp);\n    }\n}\n/**\n * Reorders the elements, moving multiple ranges of child elements to the start.\n */\nexport function sendToBack(ranges, elements) {\n    let i = 0;\n    let n = 0;\n    const len = ranges.length;\n    for (; i < len; i++) {\n        const { start, end } = ranges[i];\n        const temp = elements.splice(start, end + 1 - start);\n        elements.splice(n, 0, ...temp);\n        n += temp.length;\n    }\n}\n/**\n * Brings to front or sends to back.\n */\nexport function reorderTo(elements, compare, getIndexes, genKeys, setIndexes) {\n    if (!elements.length) {\n        return;\n    }\n    elements.sort(compare);\n    const { start, end } = getIndexes(elements);\n    const keys = genKeys(start, end, elements.length);\n    setIndexes(keys, elements);\n}\n/**\n * Brings forward or sends backward layer by layer.\n */\nexport function reorder(elements, compare, pick, getIndexes, order, genKeys, setIndexes) {\n    if (!elements.length) {\n        return;\n    }\n    elements.sort(compare);\n    const pickedElements = pick().sort(compare);\n    const { start, end } = getIndexes(pickedElements);\n    const indexes = getIndexesWith(elements, pickedElements);\n    const ranges = generateRanges(indexes);\n    order(ranges, pickedElements);\n    const keys = genKeys(start, end, pickedElements.length);\n    setIndexes(keys, pickedElements);\n}\n/**\n * Generates bounds with selected elements.\n */\nexport function generateBounds(elements, getXYWH) {\n    const bounds = {\n        x: 0,\n        y: 0,\n        w: 0,\n        h: 0,\n    };\n    const len = elements.length;\n    if (len) {\n        let i = 0;\n        const { x, y, w, h } = getXYWH(elements[i]);\n        let minX = x;\n        let minY = y;\n        let maxX = x + w;\n        let maxY = y + h;\n        for (i++; i < len; i++) {\n            const { x, y, w, h } = getXYWH(elements[i]);\n            minX = Math.min(minX, x);\n            minY = Math.min(minY, y);\n            maxX = Math.max(maxX, x + w);\n            maxY = Math.max(maxY, y + h);\n        }\n        bounds.x = minX;\n        bounds.y = minY;\n        bounds.w = maxX - minX;\n        bounds.h = maxY - minY;\n    }\n    return bounds;\n}\n//# sourceMappingURL=reordering.js.map","/**\n * This file should be pure, which means cannot modify global environment\n *  and couldn't cause differ between server and browser.\n *\n * Simply put, `import '@blocksuite/blocks/std.ts'` should work well in the Next.js\n */\nexport * from './block-range.js';\nexport * from './common-operations.js';\nexport * from './drag-and-drop.js';\nexport * from './event.js';\nexport * from './filesys.js';\nexport * from './hotkey.js';\nexport * from './query.js';\nexport * from './rect.js';\nexport * from './reordering.js';\nexport * from './selection.js';\n// Compat with SSR\nexport * from './std.js';\nexport * from './types.js';\n//# sourceMappingURL=index.js.map","import { BLOCK_CHILDREN_CONTAINER_PADDING_LEFT as PADDING_LEFT, BLOCK_ID_ATTR as ATTR, } from '@blocksuite/global/config';\nimport { assertExists, matchFlavours } from '@blocksuite/global/utils';\nimport { activeEditorManager } from '../../__internal__/utils/active-editor-manager.js';\nimport {} from '../../__internal__/utils/types.js';\nimport { Rect } from './rect.js';\nimport { getCurrentNativeRange } from './selection.js';\nimport { clamp } from './std.js';\nconst ATTR_SELECTOR = `[${ATTR}]`;\n// margin-top: calc(var(--affine-paragraph-space) + 24px);\n// h1.margin-top = 8px + 24px = 32px;\nconst MAX_SPACE = 32;\nconst STEPS = MAX_SPACE / 2 / 2;\n/**\n * @deprecated Use `page.getParent` instead\n */\nexport function getParentBlockById(id, ele = document.body) {\n    const currentBlock = getBlockElementById(id, ele);\n    return (currentBlock?.parentElement?.closest(ATTR_SELECTOR) || null);\n}\n/**\n *\n * @example\n * ```md\n * page\n * - frame\n *  - paragraph <- when invoked here, the traverse order will be following\n *    - child <- 1\n *  - sibling <- 2\n * - frame <- 3 (will be skipped)\n *   - paragraph <- 4\n * ```\n *\n * NOTE: this method will skip the `affine:frame` block\n */\nexport function getNextBlock(model, map = {}) {\n    if (model.id in map) {\n        throw new Error(\"Can't get next block! There's a loop in the block tree!\");\n    }\n    map[model.id] = true;\n    const page = model.page;\n    if (model.children.length) {\n        return model.children[0];\n    }\n    let currentBlock = model;\n    while (currentBlock) {\n        const nextSibling = page.getNextSibling(currentBlock);\n        if (nextSibling) {\n            // Assert nextSibling is not possible to be `affine:page`\n            if (matchFlavours(nextSibling, ['affine:frame'])) {\n                return getNextBlock(nextSibling);\n            }\n            return nextSibling;\n        }\n        currentBlock = page.getParent(currentBlock);\n    }\n    return null;\n}\n/**\n *\n * @example\n * ```md\n * page\n * - frame\n *   - paragraph <- 5\n * - frame <- 4 (will be skipped)\n *  - paragraph <- 3\n *    - child <- 2\n *      - child <- 1\n *  - paragraph <- when invoked here, the traverse order will be above\n * ```\n *\n * NOTE: this method will skip the `affine:frame` and `affine:page` block\n */\nexport function getPreviousBlock(model, map = {}) {\n    if (model.id in map) {\n        throw new Error(\"Can't get previous block! There's a loop in the block tree!\");\n    }\n    map[model.id] = true;\n    const page = model.page;\n    const parentBlock = page.getParent(model);\n    if (!parentBlock) {\n        return null;\n    }\n    const previousBlock = page.getPreviousSibling(model);\n    if (!previousBlock) {\n        if (matchFlavours(parentBlock, [\n            'affine:frame',\n            'affine:page',\n            'affine:database',\n        ])) {\n            return getPreviousBlock(parentBlock);\n        }\n        return parentBlock;\n    }\n    if (previousBlock.children.length) {\n        let lastChild = previousBlock.children[previousBlock.children.length - 1];\n        while (lastChild.children.length) {\n            lastChild = lastChild.children[lastChild.children.length - 1];\n        }\n        // Assume children is not possible to be `affine:frame` or `affine:page`\n        return lastChild;\n    }\n    return previousBlock;\n}\n/**\n * Returns `DefaultPageBlockComponent` | `EdgelessPageBlockComponent` if it exists\n * otherwise return `null`.\n */\nexport function getPageBlock(model) {\n    assertExists(model.page.root);\n    return document.querySelector(`[${ATTR}=\"${model.page.root.id}\"]`);\n}\n/**\n * If it's not in the page mode, it will return `null` directly.\n */\nexport function getDefaultPage(page) {\n    const editor = getEditorContainer(page);\n    if (editor.mode !== 'page')\n        return null;\n    const pageComponent = editor.querySelector('affine-default-page');\n    return pageComponent;\n}\n/**\n * If it's not in the edgeless mode, it will return `null` directly.\n */\nexport function getEdgelessPage(page) {\n    const editor = getEditorContainer(page);\n    if (editor.mode !== 'edgeless')\n        return null;\n    const pageComponent = editor.querySelector('affine-edgeless-page');\n    return pageComponent;\n}\n/**\n * This function exposes higher levels of abstraction.\n *\n * PLEASE USE IT WITH CAUTION!\n */\nexport function getEditorContainer(page) {\n    assertExists(page.root, 'Failed to check page mode! Page root is not exists!');\n    const pageBlock = getBlockElementById(page.root.id);\n    // EditorContainer\n    const editorContainer = pageBlock?.closest('editor-container');\n    assertExists(editorContainer);\n    return editorContainer;\n}\nexport function getEditorContainerByElement(ele) {\n    // EditorContainer\n    const editorContainer = ele.closest('editor-container');\n    assertExists(editorContainer);\n    return editorContainer;\n}\nexport function isPageMode(page) {\n    const editor = getEditorContainer(page);\n    if (!('mode' in editor)) {\n        throw new Error('Failed to check page mode! Editor mode is not exists!');\n    }\n    return editor.mode === 'page';\n}\n/**\n * Get editor viewport element.\n *\n * @example\n * ```ts\n * const viewportElement = getViewportElement(this.model.page);\n * if (!viewportElement) return;\n * this._disposables.addFromEvent(viewportElement, 'scroll', () => {\n *   updatePosition();\n * });\n * ```\n */\nexport function getViewportElement(page) {\n    const isPage = isPageMode(page);\n    if (!isPage)\n        return null;\n    assertExists(page.root);\n    const defaultPageBlock = document.querySelector(`[${ATTR}=\"${page.root.id}\"]`);\n    if (!defaultPageBlock ||\n        defaultPageBlock.closest('affine-default-page') !== defaultPageBlock) {\n        throw new Error('Failed to get viewport element!');\n    }\n    return defaultPageBlock.viewportElement;\n}\nexport function getBlockElementByModel(model) {\n    assertExists(model.page.root);\n    const editor = activeEditorManager.getActiveEditor();\n    const page = (editor ?? document).querySelector(`[${ATTR}=\"${model.page.root.id}\"]`);\n    if (!page)\n        return null;\n    if (model.id === model.page.root.id) {\n        return page;\n    }\n    return page.querySelector(`[${ATTR}=\"${model.id}\"]`);\n}\nexport function asyncGetBlockElementByModel(model) {\n    assertExists(model.page.root);\n    const editor = activeEditorManager.getActiveEditor();\n    const page = (editor ?? document).querySelector(`[${ATTR}=\"${model.page.root.id}\"]`);\n    if (!page)\n        return Promise.resolve(null);\n    if (model.id === model.page.root.id) {\n        return Promise.resolve(page);\n    }\n    let resolved = false;\n    return new Promise((resolve, reject) => {\n        const onSuccess = (element) => {\n            resolved = true;\n            observer.disconnect();\n            resolve(element);\n        };\n        const onFail = () => {\n            observer.disconnect();\n            reject(new Error(`Cannot find block element by model: ${model.flavour} id: ${model.id}`));\n        };\n        const observer = new MutationObserver(() => {\n            const blockElement = page.querySelector(`[${ATTR}=\"${model.id}\"]`);\n            if (blockElement) {\n                onSuccess(blockElement);\n            }\n        });\n        observer.observe(page, {\n            childList: true,\n            subtree: true,\n        });\n        requestAnimationFrame(() => {\n            if (!resolved) {\n                const blockElement = getBlockElementByModel(model);\n                if (blockElement) {\n                    onSuccess(blockElement);\n                }\n                else {\n                    onFail();\n                }\n            }\n        });\n    });\n}\nexport function getStartModelBySelection(range = getCurrentNativeRange()) {\n    const startContainer = range.startContainer instanceof Text\n        ? range.startContainer.parentElement\n        : range.startContainer;\n    const startComponent = startContainer.closest(`[${ATTR}]`);\n    if (!startComponent) {\n        return null;\n    }\n    const startModel = startComponent.model;\n    if (matchFlavours(startModel, ['affine:frame', 'affine:page'])) {\n        return null;\n    }\n    return startModel;\n}\n/**\n * @deprecated In most cases, you not need RichText, you can use {@link getVirgoByModel} instead.\n */\nexport function getRichTextByModel(model) {\n    const blockElement = getBlockElementByModel(model);\n    const richText = blockElement?.querySelector('rich-text');\n    if (!richText)\n        return null;\n    return richText;\n}\nexport async function asyncGetRichTextByModel(model) {\n    const blockElement = await asyncGetBlockElementByModel(model);\n    const richText = blockElement?.querySelector('rich-text');\n    if (!richText)\n        return null;\n    return richText;\n}\nexport function getVirgoByModel(model) {\n    if (matchFlavours(model, ['affine:database'])) {\n        // Not support database model since it's may be have multiple Virgo instances.\n        // Support to enter the editing state through the Enter key in the database.\n        return null;\n    }\n    const richText = getRichTextByModel(model);\n    if (!richText)\n        return null;\n    return richText.vEditor;\n}\nexport async function asyncGetVirgoByModel(model) {\n    if (matchFlavours(model, ['affine:database'])) {\n        // Not support database model since it's may be have multiple Virgo instances.\n        throw new Error('Cannot get virgo by database model!');\n    }\n    const richText = await asyncGetRichTextByModel(model);\n    if (!richText)\n        return null;\n    return richText.vEditor;\n}\n// TODO fix find embed model\nexport function getModelsByRange(range) {\n    // filter comment\n    if (range.startContainer.nodeType === Node.COMMENT_NODE ||\n        range.endContainer.nodeType === Node.COMMENT_NODE ||\n        range.commonAncestorContainer.nodeType === Node.COMMENT_NODE) {\n        return [];\n    }\n    let commonAncestor = range.commonAncestorContainer;\n    if (commonAncestor.nodeType === Node.TEXT_NODE) {\n        const model = getStartModelBySelection(range);\n        if (!model)\n            return [];\n        return [model];\n    }\n    if (commonAncestor.attributes &&\n        !commonAncestor.attributes.getNamedItem(ATTR)) {\n        const parentElement = commonAncestor.closest(ATTR_SELECTOR)\n            ?.parentElement;\n        if (parentElement != null) {\n            commonAncestor = parentElement;\n        }\n    }\n    const intersectedModels = [];\n    const blockElements = commonAncestor.querySelectorAll(ATTR_SELECTOR);\n    if (!blockElements.length)\n        return [];\n    if (blockElements.length === 1) {\n        const model = getStartModelBySelection(range);\n        if (!model)\n            return [];\n        return [model];\n    }\n    Array.from(blockElements)\n        .filter(element => 'model' in element)\n        .forEach(element => {\n        const block = element;\n        if (!block.model)\n            return;\n        const mainElement = matchFlavours(block.model, ['affine:page'])\n            ? element?.querySelector('.affine-default-page-block-title-container')\n            : element?.querySelector('rich-text') || element?.querySelector('img');\n        if (mainElement &&\n            range.intersectsNode(mainElement) &&\n            !matchFlavours(block.model, ['affine:frame', 'affine:page'])) {\n            intersectedModels.push(block.model);\n        }\n    });\n    return intersectedModels;\n}\nexport function getModelByElement(element) {\n    const closestBlock = element.closest(ATTR_SELECTOR);\n    assertExists(closestBlock, 'Cannot find block element by element');\n    return getModelByBlockElement(closestBlock);\n}\nfunction mergeRect(a, b) {\n    return new DOMRect(Math.min(a.left, b.left), Math.min(a.top, b.top), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top));\n}\nexport function getDOMRectByLine(rectList, lineType) {\n    const list = Array.from(rectList);\n    if (lineType === 'first') {\n        let flag = 0;\n        for (let i = 0; i < list.length; i++) {\n            if (list[i].left < 0 && list[i].right < 0 && list[i].height === 1)\n                break;\n            flag = i;\n        }\n        const subList = list.slice(0, flag + 1);\n        return subList.reduce(mergeRect);\n    }\n    else {\n        let flag = list.length - 1;\n        for (let i = list.length - 1; i >= 0; i--) {\n            if (list[i].height === 0)\n                break;\n            flag = i;\n        }\n        const subList = list.slice(flag);\n        return subList.reduce(mergeRect);\n    }\n}\nexport function isInsideRichText(element) {\n    // Fool-proofing\n    if (element instanceof Event) {\n        throw new Error('Did you mean \"event.target\"?');\n    }\n    if (!element || !(element instanceof Element)) {\n        return false;\n    }\n    const richText = element.closest('rich-text');\n    return !!richText;\n}\nexport function isInsidePageTitle(element) {\n    const editor = activeEditorManager.getActiveEditor();\n    const titleElement = (editor ?? document).querySelector('[data-block-is-title=\"true\"]');\n    if (!titleElement)\n        return false;\n    return titleElement.contains(element);\n}\nexport function isInsideEdgelessTextEditor(element) {\n    const editor = activeEditorManager.getActiveEditor();\n    const textElement = (editor ?? document).querySelector('surface-text-editor');\n    if (!textElement)\n        return false;\n    return textElement.contains(element);\n}\nexport function isToggleIcon(element) {\n    return (element instanceof SVGPathElement &&\n        element.getAttribute('data-is-toggle-icon') === 'true');\n}\nexport function isDatabaseInput(element) {\n    return (element instanceof HTMLElement &&\n        element.getAttribute('data-virgo-root') === 'true' &&\n        !!element.closest('affine-database'));\n}\nexport function isRawInput(element) {\n    return (element instanceof HTMLInputElement && !!element.closest('affine-database'));\n}\nexport function isInsideDatabaseTitle(element) {\n    const titleElement = document.querySelector('[data-block-is-database-title=\"true\"]');\n    if (!titleElement)\n        return false;\n    return titleElement.contains(element);\n}\nexport function isCaptionElement(node) {\n    if (!(node instanceof Element)) {\n        return false;\n    }\n    return node.classList.contains('affine-embed-wrapper-caption');\n}\nexport function getElementFromEventTarget(target) {\n    if (!target)\n        return null;\n    if (target instanceof Element)\n        return target;\n    if (target instanceof Node)\n        target.parentElement;\n    return null;\n}\n/**\n * Returns `16` if node is contained in the parent.\n * Otherwise return `0`.\n */\nexport function contains(parent, node) {\n    return (parent.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY);\n}\n/**\n * Returns `true` if node is contained in the elements.\n */\nexport function isContainedIn(elements, node) {\n    return elements.some(parent => contains(parent, node));\n}\n/**\n * Returns `true` if element has `data-block-id` attribute.\n */\nexport function hasBlockId(element) {\n    return element.hasAttribute(ATTR);\n}\n/**\n * Returns `true` if element is default page.\n */\nexport function isDefaultPage({ tagName }) {\n    return tagName === 'AFFINE-DEFAULT-PAGE';\n}\n/**\n * Returns `true` if element is edgeless page.\n */\nexport function isEdgelessPage({ tagName }) {\n    return tagName === 'AFFINE-EDGELESS-PAGE';\n}\n/**\n * Returns `true` if element is default/edgeless page or frame.\n */\nexport function isPageOrFrameOrSurface(element) {\n    return (isDefaultPage(element) ||\n        isEdgelessPage(element) ||\n        isFrame(element) ||\n        isSurface(element));\n}\n/**\n * Returns `true` if element is not page or frame.\n */\nexport function isBlock(element) {\n    return !isPageOrFrameOrSurface(element);\n}\n/**\n * Returns `true` if element is image.\n */\nexport function isImage({ tagName, firstElementChild }) {\n    return (tagName === 'AFFINE-EMBED' && firstElementChild?.tagName === 'AFFINE-IMAGE');\n}\n/**\n * Returns `true` if element is frame.\n */\nfunction isFrame({ tagName }) {\n    return tagName === 'AFFINE-FRAME';\n}\n/**\n * Returns `true` if element is surface.\n */\nfunction isSurface({ tagName }) {\n    return tagName === 'AFFINE-SURFACE';\n}\n/**\n * Returns `true` if element is embed.\n */\nfunction isEmbed({ tagName }) {\n    return tagName === 'AFFINE-EMBED';\n}\n/**\n * Returns `true` if element is database.\n */\nfunction isDatabase({ tagName }) {\n    return tagName === 'AFFINE-DATABASE-TABLE' || tagName === 'AFFINE-DATABASE';\n}\n/**\n * Returns `true` if element is edgeless block child.\n */\nexport function isEdgelessBlockChild({ classList }) {\n    return classList.contains('affine-edgeless-block-child');\n}\n/**\n * Returns the closest block element by a point in the rect.\n *\n * ```\n * ############### block\n * ||############# block\n * ||||########### block\n * ||||    ...\n * ||||  y - 2 * n\n * ||||    ...\n * ||||----------- cursor\n * ||||    ...\n * ||||  y + 2 * n\n * ||||    ...\n * ||||########### block\n * ||############# block\n * ############### block\n * ```\n */\nexport function getClosestBlockElementByPoint(point, state = null, scale = 1) {\n    const { y } = point;\n    let container;\n    let element = null;\n    let bounds = null;\n    let childBounds = null;\n    let diff = 0;\n    let n = 1;\n    if (state) {\n        const { snapToEdge = { x: true, y: false } } = state;\n        container = state.container;\n        const rect = state.rect || container?.getBoundingClientRect();\n        if (rect) {\n            if (snapToEdge.x) {\n                point.x = Math.min(Math.max(point.x, rect.left) + PADDING_LEFT * scale - 1, rect.right - PADDING_LEFT * scale - 1);\n            }\n            if (snapToEdge.y) {\n                // TODO handle scale\n                if (scale !== 1) {\n                    console.warn('scale is not supported yet');\n                }\n                point.y = clamp(point.y, rect.top + 1, rect.bottom - 1);\n            }\n        }\n    }\n    // find block element\n    element = findBlockElement(document.elementsFromPoint(point.x, point.y), container);\n    // Horizontal direction: for nested structures\n    if (element) {\n        // Database\n        if (isDatabase(element)) {\n            bounds = element.getBoundingClientRect();\n            const rows = getDatabaseBlockRowsElement(element);\n            assertExists(rows);\n            childBounds = rows.getBoundingClientRect();\n            if (childBounds.height) {\n                if (point.y < childBounds.top || point.y > childBounds.bottom) {\n                    return element;\n                }\n                childBounds = null;\n            }\n            else {\n                return element;\n            }\n        }\n        else {\n            // Indented paragraphs or list\n            bounds = getRectByBlockElement(element);\n            childBounds = element\n                .querySelector('.affine-block-children-container')\n                ?.firstElementChild?.getBoundingClientRect();\n            if (childBounds && childBounds.height) {\n                if (bounds.x < point.x && point.x <= childBounds.x) {\n                    return element;\n                }\n                childBounds = null;\n            }\n            else {\n                return element;\n            }\n        }\n        bounds = null;\n        element = null;\n    }\n    // Vertical direction\n    do {\n        point.y = y - n * 2;\n        if (n < 0)\n            n--;\n        n *= -1;\n        // find block element\n        element = findBlockElement(document.elementsFromPoint(point.x, point.y), container);\n        if (element) {\n            bounds = getRectByBlockElement(element);\n            diff = bounds.bottom - point.y;\n            if (diff >= 0 && diff <= STEPS * 2) {\n                return element;\n            }\n            diff = point.y - bounds.top;\n            if (diff >= 0 && diff <= STEPS * 2) {\n                return element;\n            }\n            bounds = null;\n            element = null;\n        }\n    } while (n <= STEPS);\n    return element;\n}\n/**\n * Returns the closest block element by element that does not contain the page element and frame element.\n */\nexport function getClosestBlockElementByElement(element) {\n    if (!element)\n        return null;\n    if (hasBlockId(element) && isBlock(element)) {\n        return element;\n    }\n    element = element.closest(ATTR_SELECTOR);\n    if (element && isBlock(element)) {\n        return element;\n    }\n    return null;\n}\n/**\n * Returns the model of the block element.\n */\nexport function getModelByBlockElement(element) {\n    const containerBlock = element;\n    // In extreme cases, the block may be loading, and the model is not yet available.\n    // For example\n    // // `<loader-element data-block-id=\"586080495:15\" data-service-loading=\"true\"></loader-element>`\n    if ('hostModel' in containerBlock) {\n        const loader = containerBlock;\n        assertExists(loader.hostModel);\n        return loader.hostModel;\n    }\n    assertExists(containerBlock.model);\n    return containerBlock.model;\n}\n/**\n * Returns all block elements in an element.\n */\nexport function getBlockElementsByElement(element = document) {\n    return Array.from(element.querySelectorAll(ATTR_SELECTOR)).filter(isBlock);\n}\n/**\n * Returns the block element by id with the parent.\n */\nexport function getBlockElementById(id, parent = activeEditorManager.getActiveEditor() ?? document) {\n    return parent.querySelector(`[${ATTR}=\"${id}\"]`);\n}\n/**\n * Returns the closest frame block element by id with the parent.\n */\nexport function getClosestFrameBlockElementById(id, parent = document) {\n    const element = getBlockElementById(id, parent);\n    if (!element)\n        return null;\n    if (isFrame(element))\n        return element;\n    return element.closest('affine-frame');\n}\n/**\n * Returns rect of the block element.\n *\n * Compatible with Safari!\n * https://github.com/toeverything/blocksuite/issues/902\n * https://github.com/toeverything/blocksuite/pull/1121\n */\nexport function getRectByBlockElement(element) {\n    if (isDatabase(element))\n        return element.getBoundingClientRect();\n    return (element.firstElementChild ?? element).getBoundingClientRect();\n}\n/**\n * Returns selected state rect of the block element.\n */\nexport function getSelectedStateRectByBlockElement(element) {\n    if (isImage(element)) {\n        const wrapper = element.querySelector('.affine-image-wrapper');\n        const resizable = element.querySelector('.resizable-img');\n        assertExists(wrapper);\n        assertExists(resizable);\n        const w = Rect.fromDOM(wrapper);\n        const r = Rect.fromDOM(resizable);\n        const d = w.intersect(r);\n        return d.toDOMRect();\n    }\n    return getRectByBlockElement(element);\n}\n/**\n * Returns block elements excluding their subtrees.\n * Only keep block elements of same level.\n */\nexport function getBlockElementsExcludeSubtrees(elements) {\n    if (elements.length <= 1)\n        return elements;\n    let parent = elements[0];\n    return elements.filter((node, index) => {\n        if (index === 0)\n            return true;\n        if (contains(parent, node)) {\n            return false;\n        }\n        else {\n            parent = node;\n            return true;\n        }\n    });\n}\n/**\n * Returns block elements including their subtrees.\n */\nexport function getBlockElementsIncludeSubtrees(elements) {\n    return elements.reduce((elements, element) => {\n        if (isDatabase(element)) {\n            elements.push(element);\n        }\n        else {\n            elements.push(element, ...getBlockElementsByElement(element));\n        }\n        return elements;\n    }, []);\n}\n/**\n * Find block element from an `Element[]`.\n * In Chrome/Safari, `document.elementsFromPoint` does not include `affine-image`.\n */\nfunction findBlockElement(elements, parent) {\n    const len = elements.length;\n    let element = null;\n    let i = 0;\n    while (i < len) {\n        element = elements[i];\n        i++;\n        // if parent does not contain element, it's ignored\n        if (parent && !contains(parent, element))\n            continue;\n        if (hasBlockId(element) && isBlock(element))\n            return element;\n        if (isEmbed(element)) {\n            if (i < len && hasBlockId(elements[i]) && isBlock(elements[i])) {\n                return elements[i];\n            }\n            return getClosestBlockElementByElement(element);\n        }\n    }\n    return null;\n}\n/**\n * query current mode whether is light or dark\n */\nexport function queryCurrentMode() {\n    const mode = getComputedStyle(document.documentElement).getPropertyValue('--affine-theme-mode');\n    if (mode.trim() === 'dark') {\n        return 'dark';\n    }\n    else {\n        return 'light';\n    }\n}\n/**\n * Get hovering frame with given a point in edgeless mode.\n */\nexport function getHoveringFrame(point) {\n    return (document.elementsFromPoint(point.x, point.y).find(isEdgelessBlockChild) ||\n        null);\n}\n/**\n * Returns `true` if the database is empty.\n */\nexport function isEmptyDatabase(model) {\n    return matchFlavours(model, ['affine:database']) && model.isEmpty();\n}\n/**\n * Gets the table of the database.\n */\nexport function getDatabaseBlockTableElement(element) {\n    return element.querySelector('.affine-database-block-table');\n}\n/**\n * Gets the column header of the database.\n */\nexport function getDatabaseBlockColumnHeaderElement(element) {\n    return element.querySelector('.affine-database-column-header');\n}\n/**\n * Gets the rows of the database.\n */\nexport function getDatabaseBlockRowsElement(element) {\n    return element.querySelector('.affine-database-block-rows');\n}\n/**\n * Returns a flag for the drop target.\n */\nexport var DropFlags;\n(function (DropFlags) {\n    DropFlags[DropFlags[\"Normal\"] = 0] = \"Normal\";\n    DropFlags[DropFlags[\"Database\"] = 1] = \"Database\";\n    DropFlags[DropFlags[\"EmptyDatabase\"] = 2] = \"EmptyDatabase\";\n})(DropFlags || (DropFlags = {}));\n/**\n * Gets the drop rect by block and point.\n */\nexport function getDropRectByPoint(point, model, element) {\n    const result = {\n        rect: getRectByBlockElement(element),\n        flag: DropFlags.Normal,\n    };\n    const isDatabase = matchFlavours(model, ['affine:database']);\n    if (isDatabase) {\n        const table = getDatabaseBlockTableElement(element);\n        assertExists(table);\n        let bounds = table.getBoundingClientRect();\n        if (model.isEmpty()) {\n            result.flag = DropFlags.EmptyDatabase;\n            if (point.y < bounds.top)\n                return result;\n            const header = getDatabaseBlockColumnHeaderElement(element);\n            assertExists(header);\n            bounds = header.getBoundingClientRect();\n            result.rect = new DOMRect(result.rect.left, bounds.bottom, result.rect.width, 1);\n        }\n        else {\n            result.flag = DropFlags.Database;\n            const rows = getDatabaseBlockRowsElement(element);\n            assertExists(rows);\n            const rowsBounds = rows.getBoundingClientRect();\n            if (point.y < rowsBounds.top || point.y > rowsBounds.bottom)\n                return result;\n            const elements = document.elementsFromPoint(point.x, point.y);\n            const len = elements.length;\n            let e;\n            let i = 0;\n            for (; i < len; i++) {\n                e = elements[i];\n                if (e.classList.contains('affine-database-block-row-cell-content')) {\n                    result.rect = getCellRect(e, bounds);\n                    return result;\n                }\n                if (e.classList.contains('affine-database-block-row')) {\n                    e = e.querySelector(ATTR_SELECTOR);\n                    assertExists(e);\n                    result.rect = getCellRect(e, bounds);\n                    return result;\n                }\n            }\n        }\n    }\n    else {\n        const parent = element.parentElement;\n        if (parent?.classList.contains('affine-database-block-row-cell-content')) {\n            result.flag = DropFlags.Database;\n            result.rect = getCellRect(parent);\n            return result;\n        }\n    }\n    return result;\n}\nfunction getCellRect(element, bounds) {\n    if (!bounds) {\n        const table = element.closest('.affine-database-block-table');\n        assertExists(table);\n        bounds = table.getBoundingClientRect();\n    }\n    // affine-database-block-row-cell\n    const col = element.parentElement;\n    assertExists(col);\n    // affine-database-block-row\n    const row = col.parentElement;\n    assertExists(row);\n    const colRect = col.getBoundingClientRect();\n    const rowRect = row.getBoundingClientRect();\n    return new DOMRect(bounds.left, rowRect.top, colRect.right - bounds.left, colRect.height);\n}\n/**\n * Returns `true` if the target is `Element`.\n */\nexport function isElement(target) {\n    return target && target instanceof Element;\n}\n/**\n * Returns `true` if the target is `affine-selected-blocks`.\n */\nexport function isSelectedBlocks(target) {\n    return target.tagName === 'AFFINE-SELECTED-BLOCKS';\n}\n/**\n * Returns `true` if the target is `affine-drag-handle`.\n */\nexport function isDragHandle(target) {\n    return target.tagName === 'AFFINE-DRAG-HANDLE';\n}\n/**\n * Returns `true` if block elements have database block element.\n */\nexport function hasDatabase(elements) {\n    return elements.some(isDatabase);\n}\n//# sourceMappingURL=query.js.map","import { clamp } from './std.js';\nexport class Point {\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n    set(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    equals({ x, y }) {\n        return this.x === x && this.y === y;\n    }\n    add(point) {\n        return new Point(this.x + point.x, this.y + point.y);\n    }\n    scale(factor) {\n        return new Point(this.x * factor, this.y * factor);\n    }\n    subtract(point) {\n        return new Point(this.x - point.x, this.y - point.y);\n    }\n    /**\n     * Returns a copy of the point.\n     */\n    clone() {\n        return new Point(this.x, this.y);\n    }\n    /**\n     * Compares and returns the minimum of two points.\n     */\n    static min(a, b) {\n        return new Point(Math.min(a.x, b.x), Math.min(a.y, b.y));\n    }\n    /**\n     * Compares and returns the maximum of two points.\n     */\n    static max(a, b) {\n        return new Point(Math.max(a.x, b.x), Math.max(a.y, b.y));\n    }\n    /**\n     * Restrict a value to a certain interval.\n     */\n    static clamp(p, min, max) {\n        return new Point(clamp(p.x, min.x, max.x), clamp(p.y, min.y, max.y));\n    }\n}\nexport class Rect {\n    constructor(left, top, right, bottom) {\n        const [minX, maxX] = left <= right ? [left, right] : [right, left];\n        const [minY, maxY] = top <= bottom ? [top, bottom] : [bottom, top];\n        this.min = new Point(minX, minY);\n        this.max = new Point(maxX, maxY);\n    }\n    get width() {\n        return this.max.x - this.min.x;\n    }\n    set width(w) {\n        this.max.x = this.min.x + w;\n    }\n    get height() {\n        return this.max.y - this.min.y;\n    }\n    set height(h) {\n        this.max.y = this.min.y + h;\n    }\n    get left() {\n        return this.min.x;\n    }\n    set left(x) {\n        this.min.x = x;\n    }\n    get top() {\n        return this.min.y;\n    }\n    set top(y) {\n        this.min.y = y;\n    }\n    get right() {\n        return this.max.x;\n    }\n    set right(x) {\n        this.max.x = x;\n    }\n    get bottom() {\n        return this.max.y;\n    }\n    set bottom(y) {\n        this.max.y = y;\n    }\n    center() {\n        return new Point((this.left + this.right) / 2, (this.top + this.bottom) / 2);\n    }\n    extend_with(point) {\n        this.min = Point.min(this.min, point);\n        this.max = Point.max(this.max, point);\n    }\n    extend_with_x(x) {\n        this.min.x = Math.min(this.min.x, x);\n        this.max.x = Math.max(this.max.x, x);\n    }\n    extend_with_y(y) {\n        this.min.y = Math.min(this.min.y, y);\n        this.max.y = Math.max(this.max.y, y);\n    }\n    equals({ min, max }) {\n        return this.min.equals(min) && this.max.equals(max);\n    }\n    contains({ min, max }) {\n        return this.isPointIn(min) && this.isPointIn(max);\n    }\n    intersects({ left, top, right, bottom }) {\n        return (this.left <= right &&\n            left <= this.right &&\n            this.top <= bottom &&\n            top <= this.bottom);\n    }\n    isPointIn({ x, y }) {\n        return (this.left <= x && x <= this.right && this.top <= y && y <= this.bottom);\n    }\n    isPointDown({ x, y }) {\n        return this.bottom < y && this.left <= x && this.right >= x;\n    }\n    isPointUp({ x, y }) {\n        return y < this.top && this.left <= x && this.right >= x;\n    }\n    isPointLeft({ x, y }) {\n        return x < this.left && this.top <= y && this.bottom >= y;\n    }\n    isPointRight({ x, y }) {\n        return x > this.right && this.top <= y && this.bottom >= y;\n    }\n    intersect(other) {\n        return Rect.fromPoints(Point.max(this.min, other.min), Point.min(this.max, other.max));\n    }\n    clamp(p) {\n        return Point.clamp(p, this.min, this.max);\n    }\n    clone() {\n        const { left, top, right, bottom } = this;\n        return new Rect(left, top, right, bottom);\n    }\n    toDOMRect() {\n        const { left, top, width, height } = this;\n        return new DOMRect(left, top, width, height);\n    }\n    static fromLTRB(left, top, right, bottom) {\n        return new Rect(left, top, right, bottom);\n    }\n    static fromLWTH(left, width, top, height) {\n        return new Rect(left, top, left + width, top + height);\n    }\n    static fromXY(x, y) {\n        return Rect.fromPoint(new Point(x, y));\n    }\n    static fromPoint(point) {\n        return Rect.fromPoints(point.clone(), point);\n    }\n    static fromPoints(start, end) {\n        const width = Math.abs(end.x - start.x);\n        const height = Math.abs(end.y - start.y);\n        const left = Math.min(end.x, start.x);\n        const top = Math.min(end.y, start.y);\n        return Rect.fromLWTH(left, width, top, height);\n    }\n    static fromDOMRect({ left, top, right, bottom }) {\n        return Rect.fromLTRB(left, top, right, bottom);\n    }\n    static fromDOM(dom) {\n        return Rect.fromDOMRect(dom.getBoundingClientRect());\n    }\n}\n//# sourceMappingURL=rect.js.map","import { BLOCK_ID_ATTR, SCROLL_THRESHOLD } from '@blocksuite/global/config';\nimport { assertExists, caretRangeFromPoint, matchFlavours, nonTextBlock, } from '@blocksuite/global/utils';\nimport { getTextNodesFromElement } from '@blocksuite/virgo';\nimport { asyncFocusRichText } from './common-operations.js';\nimport { getBlockElementByModel, getDefaultPage, getElementFromEventTarget, getModelByElement, getModelsByRange, getNextBlock, getPageBlock, getPreviousBlock, } from './query.js';\nimport { Rect } from './rect.js';\n// /[\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]/u\nconst notStrictCharacterReg = /[^\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}\\p{Join_C}]/u;\nconst notStrictCharacterAndSpaceReg = /[^\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}\\p{Join_C}\\s]/u;\nfunction setStartRange(editableContainer) {\n    const newRange = document.createRange();\n    let firstNode = editableContainer.firstChild;\n    while (firstNode?.firstChild) {\n        firstNode = firstNode.firstChild;\n    }\n    if (firstNode) {\n        newRange.setStart(firstNode, 0);\n        newRange.setEnd(firstNode, 0);\n    }\n    return newRange;\n}\nfunction setEndRange(editableContainer) {\n    const newRange = document.createRange();\n    let lastNode = editableContainer.lastChild;\n    while (lastNode?.lastChild) {\n        lastNode = lastNode.lastChild;\n    }\n    if (lastNode) {\n        newRange.setStart(lastNode, lastNode.textContent?.length || 0);\n        newRange.setEnd(lastNode, lastNode.textContent?.length || 0);\n    }\n    return newRange;\n}\nasync function setNewTop(y, editableContainer, zoom = 1) {\n    const scrollContainer = editableContainer.closest('.affine-default-viewport');\n    const { top, bottom } = Rect.fromDOM(editableContainer);\n    const { clientHeight } = document.documentElement;\n    const lineHeight = (Number(window.getComputedStyle(editableContainer).lineHeight.replace(/\\D+$/, '')) || 16) * zoom;\n    const compare = bottom < y;\n    switch (compare) {\n        case true: {\n            let finalBottom = bottom;\n            if (bottom < SCROLL_THRESHOLD && scrollContainer) {\n                scrollContainer.scrollTop =\n                    scrollContainer.scrollTop - SCROLL_THRESHOLD + bottom;\n                // set scroll may have an animation, wait for over\n                requestAnimationFrame(() => {\n                    finalBottom = editableContainer.getBoundingClientRect().bottom;\n                });\n            }\n            return finalBottom - lineHeight / 2;\n        }\n        case false: {\n            let finalTop = top;\n            if (scrollContainer && top > clientHeight - SCROLL_THRESHOLD) {\n                scrollContainer.scrollTop =\n                    scrollContainer.scrollTop + (top + SCROLL_THRESHOLD - clientHeight);\n                // set scroll may has a animation, wait for over\n                requestAnimationFrame(() => {\n                    finalTop = editableContainer.getBoundingClientRect().top;\n                });\n            }\n            return finalTop + lineHeight / 2;\n        }\n    }\n}\n/**\n * As the title is a text area, this function does not yet have support for `SelectionPosition`.\n */\nexport function focusTitle(page, index = Infinity, len = 0) {\n    // TODO support SelectionPosition\n    const pageComponent = getDefaultPage(page);\n    if (!pageComponent) {\n        throw new Error(\"Can't find page component!\");\n    }\n    if (!pageComponent.titleVEditor) {\n        throw new Error(\"Can't find title vEditor!\");\n    }\n    if (index > pageComponent.titleVEditor.yText.length) {\n        index = pageComponent.titleVEditor.yText.length;\n    }\n    pageComponent.titleVEditor.setVRange({ index, length: len });\n}\nexport async function focusRichText(editableContainer, position = 'end', zoom = 1) {\n    // TODO optimize how get scroll container\n    const { left, right } = Rect.fromDOM(editableContainer);\n    editableContainer\n        .querySelector('v-line')\n        ?.scrollIntoView({ block: 'nearest' });\n    let range = null;\n    switch (position) {\n        case 'start':\n            range = setStartRange(editableContainer);\n            break;\n        case 'end':\n            range = setEndRange(editableContainer);\n            break;\n        default: {\n            const { x, y } = position;\n            let newLeft = x;\n            const newTop = await setNewTop(y, editableContainer, zoom);\n            if (x <= left) {\n                newLeft = left + 1;\n            }\n            if (x >= right) {\n                newLeft = right - 1;\n            }\n            range = caretRangeFromPoint(newLeft, newTop);\n            break;\n        }\n    }\n    resetNativeSelection(range);\n}\nexport function focusBlockByModel(model, position = 'end', zoom = 1) {\n    if (matchFlavours(model, ['affine:frame', 'affine:page'])) {\n        throw new Error(\"Can't focus frame or page!\");\n    }\n    const pageBlock = getPageBlock(model);\n    assertExists(pageBlock);\n    const isPageMode = pageBlock.tagName === 'AFFINE-DEFAULT-PAGE';\n    // If focus on a follow block, we should select the block\n    if (isPageMode &&\n        matchFlavours(model, [\n            'affine:embed',\n            'affine:divider',\n            'affine:code',\n            'affine:database',\n            'affine:bookmark',\n        ])) {\n        pageBlock.selection.state.clearSelection();\n        const rect = getBlockElementByModel(model)?.getBoundingClientRect();\n        rect && pageBlock.slots.selectedRectsUpdated.emit([rect]);\n        const element = getBlockElementByModel(model);\n        assertExists(element);\n        pageBlock.selection.state.selectedBlocks.push(element);\n        if (matchFlavours(model, ['affine:database'])) {\n            const elements = model.children\n                .map(child => getBlockElementByModel(child))\n                .filter((element) => element !== null);\n            pageBlock.selection.state.selectedBlocks.push(...elements);\n        }\n        pageBlock.selection.state.type = 'block';\n        resetNativeSelection(null);\n        document.activeElement.blur();\n        return;\n    }\n    const element = getBlockElementByModel(model);\n    const editableContainer = element?.querySelector('[contenteditable]');\n    if (editableContainer) {\n        if (isPageMode) {\n            pageBlock.selection.state.clearSelection();\n            pageBlock.selection.setFocusedBlock(element);\n        }\n        focusRichText(editableContainer, position, zoom);\n    }\n}\nexport function focusPreviousBlock(model, position = 'start', zoom = 1) {\n    const pageBlock = getPageBlock(model);\n    assertExists(pageBlock);\n    let nextPosition = position;\n    if (pageBlock.tagName === 'AFFINE-DEFAULT-PAGE') {\n        if (nextPosition) {\n            pageBlock.lastSelectionPosition = nextPosition;\n        }\n        else if (pageBlock.lastSelectionPosition) {\n            nextPosition = pageBlock.lastSelectionPosition;\n        }\n    }\n    const preNodeModel = getPreviousBlock(model);\n    if (preNodeModel && nextPosition) {\n        focusBlockByModel(preNodeModel, nextPosition, zoom);\n    }\n}\nexport function focusNextBlock(model, position = 'start', zoom = 1) {\n    const pageBlock = getPageBlock(model);\n    assertExists(pageBlock);\n    let nextPosition = position;\n    if (pageBlock.tagName === 'AFFINE-DEFAULT-PAGE') {\n        if (nextPosition) {\n            pageBlock.lastSelectionPosition = nextPosition;\n        }\n        else if (pageBlock.lastSelectionPosition) {\n            nextPosition = pageBlock.lastSelectionPosition;\n        }\n    }\n    const nextNodeModel = getNextBlock(model);\n    if (nextNodeModel) {\n        focusBlockByModel(nextNodeModel, nextPosition, zoom);\n    }\n}\nexport function resetNativeSelection(range) {\n    const selection = window.getSelection();\n    assertExists(selection);\n    selection.removeAllRanges();\n    range && selection.addRange(range);\n}\nexport function clearSelection(page) {\n    if (!page.root)\n        return;\n    getPageBlock(page.root)?.selection.clear();\n}\n/**\n * Return true if has native selection in the document.\n *\n * @example\n * ```ts\n * const isNativeSelection = hasNativeSelection();\n * if (isNativeSelection) {\n *   // do something\n * }\n * ```\n */\nexport function hasNativeSelection() {\n    const selection = window.getSelection();\n    if (!selection)\n        return false;\n    // The `selection.rangeCount` attribute must return 0\n    // if this is empty or either focus or anchor is not in the document tree,\n    // and must return 1 otherwise.\n    return !!selection.rangeCount;\n}\nexport function isCollapsedNativeSelection() {\n    const selection = window.getSelection();\n    if (!selection)\n        return false;\n    return selection.isCollapsed;\n}\nexport function isRangeNativeSelection() {\n    const selection = window.getSelection();\n    if (!selection)\n        return false;\n    return !selection.isCollapsed;\n}\n/**\n * Determine if the range contains multiple block.\n *\n * Please check the difference between {@link isMultiLineRange} before use this function\n */\nexport function isMultiBlockRange(range = getCurrentNativeRange()) {\n    return getModelsByRange(range).length > 1;\n}\n/**\n * Determine if the range contains multiple lines.\n *\n * Note that this function is very similar to {@link isMultiBlockRange},\n * but they are slightly different.\n *\n * Consider the following scenarios:\n * One block contains multiple lines,\n * if you select multiple lines of text under this block,\n * this function will return true,\n * but {@link isMultiBlockRange} will return false.\n */\nexport function isMultiLineRange(range = getCurrentNativeRange()) {\n    // Get the selection height\n    const { height } = range.getBoundingClientRect();\n    const oneLineRange = document.createRange();\n    oneLineRange.setStart(range.startContainer, range.startOffset);\n    // Get the base line height\n    const { height: oneLineHeight } = oneLineRange.getBoundingClientRect();\n    return height > oneLineHeight;\n}\nexport function getCurrentNativeRange(selection = window.getSelection()) {\n    // When called on an <iframe> that is not displayed (e.g., where display: none is set) Firefox will return null\n    // See https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection for more details\n    if (!selection) {\n        throw new Error('Failed to get current range, selection is null');\n    }\n    // Before the user has clicked a freshly loaded page, the rangeCount is 0.\n    // The rangeCount will usually be 1.\n    // But scripting can be used to make the selection contain more than one range.\n    // See https://developer.mozilla.org/en-US/docs/Web/API/Selection/rangeCount for more details.\n    if (selection.rangeCount === 0) {\n        throw new Error('Failed to get current range, rangeCount is 0');\n    }\n    if (selection.rangeCount > 1) {\n        console.warn('getCurrentRange may be wrong, rangeCount > 1');\n    }\n    return selection.getRangeAt(0);\n}\nfunction handleInFrameDragMove(startContainer, startOffset, endContainer, endOffset, currentRange, isBackward) {\n    if (isBackward) {\n        currentRange.setEnd(endContainer, endOffset);\n    }\n    else {\n        currentRange.setStart(startContainer, startOffset);\n    }\n    resetNativeSelection(currentRange);\n}\nexport function handleNativeRangeDragMove(startRange, e) {\n    const isEdgelessMode = !!document.querySelector('affine-edgeless-page');\n    const { clientX: x, clientY: y, target } = e.raw;\n    // Range from current mouse position\n    let currentRange = caretRangeFromPoint(x, y);\n    if (!currentRange)\n        return;\n    assertExists(startRange);\n    const { startContainer, startOffset, endContainer, endOffset } = startRange;\n    const _startContainer = (startContainer.nodeType === Node.TEXT_NODE\n        ? startContainer.parentElement\n        : startContainer);\n    const startFrame = _startContainer.closest('affine-frame');\n    if (!startFrame)\n        return;\n    let currentFrame = null;\n    let shouldUpdateCurrentRange = false;\n    if (isEdgelessMode) {\n        currentFrame = startFrame;\n        shouldUpdateCurrentRange = true;\n    }\n    else {\n        const el = document.elementFromPoint(x, y);\n        if (el?.classList.contains('virgo-editor')) {\n            return;\n        }\n        currentFrame = el?.closest('affine-frame');\n        const currentEditor = el?.closest('.virgo-editor');\n        // if we are not pointing at an editor, we should update the current range\n        // if we are not even pointing at a frame, we should find one and update the current range\n        shouldUpdateCurrentRange = !currentFrame || !currentEditor;\n        currentFrame ?? (currentFrame = getClosestFrame(y));\n    }\n    if (!currentFrame)\n        return;\n    if (shouldUpdateCurrentRange) {\n        let closestEditor = null;\n        // In some cases, the target element may be HTMLDocument.\n        if (target && 'closest' in target) {\n            closestEditor = target.closest('.virgo-editor');\n        }\n        if (!closestEditor) {\n            closestEditor = getClosestEditor(y, currentFrame);\n        }\n        if (!closestEditor)\n            return;\n        const newPoint = normalizePointIntoContainer({ x, y }, closestEditor);\n        currentRange = caretRangeFromPoint(newPoint.x, newPoint.y);\n        if (!currentRange)\n            return;\n        if (currentRange.endContainer.nodeType !== Node.TEXT_NODE)\n            return;\n        if (!currentFrame.contains(currentRange.endContainer))\n            return;\n    }\n    // Forward: ↓ →, Backward: ← ↑\n    const isBackward = currentRange.comparePoint(endContainer, endOffset) === 1;\n    handleInFrameDragMove(startContainer, startOffset, endContainer, endOffset, currentRange, isBackward);\n}\n/**\n * This function is used to normalize the point into the reasonable range of the container.\n *\n * It will set the point to the top-left or bottom-right corner\n * when the point is out of the horizontal range of container.\n */\nfunction normalizePointIntoContainer(point, container) {\n    const { top, left, right, bottom } = container.getBoundingClientRect();\n    const newPoint = { ...point };\n    const { x, y } = point;\n    // need this offset to avoid the point is out of the container\n    if (y < top) {\n        newPoint.y = top + 4;\n        newPoint.x = left + 4;\n    }\n    else if (y > bottom) {\n        newPoint.y = bottom - 4;\n        newPoint.x = right - 4;\n    }\n    else {\n        if (x < left) {\n            newPoint.x = left;\n        }\n        else if (x > right) {\n            newPoint.x = right;\n        }\n    }\n    return newPoint;\n}\nexport function isBlankArea(e) {\n    const { cursor } = window.getComputedStyle(e.raw.target);\n    return cursor !== 'text';\n}\n// Retarget selection back to the nearest block\n// when user clicks on the edge of page (page mode) or frame (edgeless mode).\n// See https://github.com/toeverything/blocksuite/pull/878\nfunction retargetClick(page, e, container) {\n    const targetElement = getElementFromEventTarget(e.raw.target);\n    const block = targetElement?.closest(`[${BLOCK_ID_ATTR}]`);\n    const parentModel = block?.model || block?.pageModel;\n    if (!parentModel)\n        return;\n    const shouldRetarget = matchFlavours(parentModel, [\n        'affine:frame',\n        'affine:page',\n    ]);\n    if (!shouldRetarget)\n        return;\n    const { clientX, clientY } = e.raw;\n    const horizontalElement = getClosestEditor(clientY, container);\n    if (horizontalElement?.closest('affine-database'))\n        return;\n    if (!horizontalElement)\n        return;\n    const model = getModelByElement(horizontalElement);\n    const rect = horizontalElement.getBoundingClientRect();\n    if (matchFlavours(model, nonTextBlock) && clientY > rect.bottom) {\n        const parent = page.getParent(model);\n        assertExists(parent);\n        const id = page.addBlock('affine:paragraph', {}, parent.id);\n        asyncFocusRichText(page, id);\n        return;\n    }\n    if (clientX < rect.left) {\n        const range = setStartRange(horizontalElement);\n        resetNativeSelection(range);\n    }\n    else {\n        const range = setEndRange(horizontalElement);\n        resetNativeSelection(range);\n    }\n}\nexport function handleNativeRangeClick(page, e, container) {\n    // if not left click\n    if (e.button)\n        return;\n    handleNativeRangeAtPoint(e.raw.clientX, e.raw.clientY);\n    retargetClick(page, e, container);\n}\nexport function handleNativeRangeAtPoint(x, y) {\n    const range = caretRangeFromPoint(x, y);\n    const startContainer = range?.startContainer;\n    // click on rich text\n    if (startContainer instanceof Node) {\n        resetNativeSelection(range);\n    }\n}\nexport function handleNativeRangeDblClick() {\n    const selection = window.getSelection();\n    if (selection && selection.isCollapsed && selection.anchorNode) {\n        const editableContainer = selection.anchorNode.parentElement?.closest('[contenteditable]');\n        if (editableContainer) {\n            return expandRangeByCharacter(selection, editableContainer);\n        }\n        return null;\n    }\n    return null;\n}\nfunction expandRangeByCharacter(selection, editableContainer) {\n    const leafNodes = leftFirstSearchLeafNodes(editableContainer);\n    if (!leafNodes.length) {\n        return null;\n    }\n    const [newRange, currentChar, currentNodeIndex] = getNewRangeForDblClick(leafNodes, selection);\n    // try select range by segmenter\n    const extendRange = trySelectBySegmenter(selection, newRange, currentChar, leafNodes, currentNodeIndex);\n    // don't mutate selection if it's not changed\n    if (extendRange) {\n        resetNativeSelection(extendRange);\n    }\n    return extendRange;\n}\nfunction getNewStartAndEndForDblClick(currentNodeIndex, leafNodes, selection, checkReg) {\n    let newStartNode = leafNodes[0];\n    let newStartOffset = 0;\n    let newEndNode = leafNodes[leafNodes.length - 1];\n    let newEndOffset = newEndNode.textContent?.length || 0;\n    // get startNode and startOffset\n    for (let i = currentNodeIndex; i >= 0; i--) {\n        const node = leafNodes[i];\n        if (node instanceof Text) {\n            const text = node.textContent?.slice(0, i === currentNodeIndex ? selection.anchorOffset : undefined);\n            if (text) {\n                const reverseText = Array.from(text).reverse().join('');\n                const index = reverseText.search(checkReg);\n                if (index !== -1) {\n                    newStartNode = node;\n                    newStartOffset = reverseText.length - index;\n                    break;\n                }\n            }\n        }\n    }\n    // get endNode and endOffset\n    for (let j = currentNodeIndex; j < leafNodes.length; j++) {\n        const node = leafNodes[j];\n        if (node instanceof Text) {\n            const text = node.textContent?.slice(j === currentNodeIndex ? selection.anchorOffset : undefined);\n            if (text) {\n                const index = text.search(checkReg);\n                if (index !== -1) {\n                    newEndNode = node;\n                    newEndOffset =\n                        j === currentNodeIndex ? selection.anchorOffset + index : index;\n                    break;\n                }\n            }\n        }\n    }\n    return [newStartNode, newStartOffset, newEndNode, newEndOffset];\n}\nfunction getNewRangeForDblClick(leafNodes, selection) {\n    let startNode = leafNodes[0];\n    let startOffset = 0;\n    let endNode = leafNodes[leafNodes.length - 1];\n    let endOffset = endNode.textContent?.length || 0;\n    // if anchorNode is Element, it always has only one child\n    const currentTextNode = selection.anchorNode instanceof Element\n        ? selection.anchorNode.firstChild\n        : selection.anchorNode;\n    const currentChar = currentTextNode?.textContent?.[selection.anchorOffset] || '';\n    const currentNodeIndex = leafNodes.findIndex(node => node === currentTextNode);\n    // if current char is not character or blank, select this char\n    if (currentChar &&\n        notStrictCharacterAndSpaceReg.test(currentChar) &&\n        currentTextNode) {\n        startNode = currentTextNode;\n        endNode = currentTextNode;\n        startOffset = selection.anchorOffset;\n        endOffset = selection.anchorOffset + 1;\n    }\n    else {\n        // expand selection to blank\n        let checkReg = notStrictCharacterReg;\n        // space only spend one char\n        if (/\\s/.test(currentChar)) {\n            checkReg = /\\S/;\n        }\n        // English character only expand English\n        if (/\\w/.test(currentChar)) {\n            checkReg = /\\W/;\n        }\n        const [newStartNode, newStartOffset, newEndNode, newEndOffset] = getNewStartAndEndForDblClick(currentNodeIndex, leafNodes, selection, checkReg);\n        startNode = newStartNode;\n        startOffset = newStartOffset;\n        endNode = newEndNode;\n        endOffset = newEndOffset;\n    }\n    const newRange = document.createRange();\n    newRange.setStart(startNode, startOffset);\n    newRange.setEnd(endNode, endOffset);\n    return [newRange, currentChar, currentNodeIndex];\n}\nfunction trySelectBySegmenter(selection, newRange, currentChar, leafNodes, currentNodeIndex) {\n    if (Intl.Segmenter &&\n        !notStrictCharacterAndSpaceReg.test(currentChar) &&\n        !/\\w/.test(currentChar)) {\n        const [currentCharIndex, wordText] = getCurrentCharIndex(newRange, leafNodes, selection, currentChar);\n        if (currentCharIndex === -1 || currentNodeIndex === -1)\n            return null;\n        // length for expand left\n        let leftLength = currentCharIndex;\n        // length for expand right\n        let rightLength = wordText.length - currentCharIndex;\n        // get and set new start node and offset\n        for (let i = currentNodeIndex; i >= 0; i--) {\n            const leafNode = leafNodes[i];\n            const allTextLength = i === currentNodeIndex\n                ? selection.anchorOffset\n                : leafNode.textContent?.length || 0;\n            if (leftLength <= allTextLength) {\n                newRange.setStart(leafNode, allTextLength - leftLength);\n                break;\n            }\n            else {\n                leftLength = leftLength - allTextLength;\n            }\n        }\n        // get and set new end node and offset\n        for (let i = currentNodeIndex; i < leafNodes.length; i++) {\n            const leafNode = leafNodes[i];\n            const textLength = leafNode.textContent?.length || 0;\n            const allTextLength = i === currentNodeIndex\n                ? textLength - selection.anchorOffset\n                : textLength;\n            if (rightLength <= allTextLength) {\n                newRange.setEnd(leafNode, textLength - allTextLength + rightLength);\n                break;\n            }\n            else {\n                rightLength = rightLength - allTextLength;\n            }\n        }\n    }\n    return newRange;\n}\nfunction getCurrentCharIndex(newRange, leafNodes, selection, currentChar) {\n    const rangeString = newRange.toString();\n    // check all languages words\n    const segmenter = new Intl.Segmenter([], { granularity: 'word' });\n    const wordsIterator = segmenter.segment(rangeString)[Symbol.iterator]();\n    const words = Array.from(wordsIterator);\n    if (words.length === 0) {\n        return [-1, ''];\n    }\n    let absoluteOffset = 0;\n    let started = false;\n    // get absolute offset of current cursor\n    for (let i = 0; i < leafNodes.length; i++) {\n        const leafNode = leafNodes[i];\n        if (started || leafNode === newRange.startContainer) {\n            started = true;\n            if (leafNode !== selection.anchorNode) {\n                absoluteOffset = absoluteOffset + (leafNode.textContent?.length || 0);\n            }\n            else {\n                absoluteOffset =\n                    absoluteOffset + selection.anchorOffset - newRange.startOffset;\n                break;\n            }\n        }\n    }\n    let wordText = words[words.length - 1].segment;\n    // get word text of current cursor\n    for (let i = 0; i < words.length; i++) {\n        const word = words[i];\n        if (absoluteOffset === word.index) {\n            wordText = word.segment;\n            break;\n        }\n        if (absoluteOffset < word.index) {\n            wordText = words[i - 1].segment;\n            break;\n        }\n    }\n    const currentCharIndex = wordText.indexOf(currentChar);\n    return [currentCharIndex, wordText];\n}\n/**\n * left first search all leaf text nodes\n * @example\n *  <div><p>he<em>ll</em>o</p><p>world</p></div>\n *  => [he, ll, o, world]\n **/\nexport function leftFirstSearchLeafNodes(node, leafNodes = []) {\n    if (node.nodeType === Node.TEXT_NODE) {\n        leafNodes.push(node);\n    }\n    else {\n        const children = node.childNodes;\n        for (let i = 0; i < children.length; i++) {\n            leftFirstSearchLeafNodes(children[i], leafNodes);\n        }\n    }\n    return leafNodes;\n}\nexport function getLastTextNode(node) {\n    return leftFirstSearchLeafNodes(node).pop();\n}\nexport function getFirstTextNode(node) {\n    return leftFirstSearchLeafNodes(node)[0];\n}\nexport function getSplicedTitle(title) {\n    const text = [...title.value];\n    assertExists(title.selectionStart);\n    assertExists(title.selectionEnd);\n    text.splice(title.selectionStart, title.selectionEnd - title.selectionStart);\n    return text.join('');\n}\nexport function isEmbed(e) {\n    if (e.raw.target.classList.contains('resize')) {\n        return true;\n    }\n    return false;\n}\nexport function isDatabase(e) {\n    const target = e.raw.target;\n    if (!(target instanceof HTMLElement)) {\n        // When user click on the list indicator,\n        // the target is not an `HTMLElement`, instead `SVGElement`.\n        return false;\n    }\n    if (\n    // target.className.startsWith('affine-database') ||\n    // // prevent select column from triggering block selection\n    // target.tagName.startsWith('AFFINE-DATABASE')\n    target.closest('affine-database-table')) {\n        return true;\n    }\n    return false;\n}\nexport function getHorizontalClosestElement(clientY, selector, container = document.body) {\n    // sort for binary search (In fact, it is generally orderly, just in case)\n    const elements = Array.from(container.querySelectorAll(selector)).sort((a, b) => \n    // getBoundingClientRect here actually run so fast because of the browser cache\n    a.getBoundingClientRect().top > b.getBoundingClientRect().top ? 1 : -1);\n    // short circuit\n    const len = elements.length;\n    if (len === 0)\n        return null;\n    if (len === 1)\n        return elements[0];\n    if (clientY < elements[0].getBoundingClientRect().top)\n        return elements[0];\n    if (clientY > elements[len - 1].getBoundingClientRect().bottom)\n        return elements[len - 1];\n    // binary search\n    let left = 0;\n    let right = len - 1;\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        const minElement = elements[mid];\n        if (clientY <= minElement.getBoundingClientRect().bottom &&\n            (mid === 0 || clientY > elements[mid - 1].getBoundingClientRect().bottom)) {\n            return elements[mid];\n        }\n        if (minElement.getBoundingClientRect().top > clientY) {\n            right = mid - 1;\n        }\n        else {\n            left = mid + 1;\n        }\n    }\n    return null;\n}\n/**\n * Get the closest editor element in the horizontal position\n */\nexport function getClosestEditor(clientY, container = document.body) {\n    return getHorizontalClosestElement(clientY, '.virgo-editor', container);\n}\n/**\n * Get the closest frame element in the horizontal position\n */\nexport function getClosestFrame(clientY) {\n    return getHorizontalClosestElement(clientY, 'affine-frame');\n}\n/**\n * Handle native range with triple click.\n */\nexport function handleNativeRangeTripleClick(e) {\n    const { raw: { clientX, clientY }, } = e;\n    const editor = document\n        .elementFromPoint(clientX, clientY)\n        ?.closest('.virgo-editor');\n    if (!editor)\n        return null;\n    const textNodes = getTextNodesFromElement(editor);\n    const first = textNodes[0];\n    const last = textNodes[textNodes.length - 1];\n    const range = new Range();\n    range.setStart(first, 0);\n    range.setEnd(last, Number(last.textContent?.length));\n    resetNativeSelection(range);\n    return range;\n}\n//# sourceMappingURL=selection.js.map","import { matchFlavours } from '@blocksuite/global/utils';\n/**\n * Whether the block supports rendering its children.\n */\nexport function supportsChildren(model) {\n    if (matchFlavours(model, [\n        // 'affine:database',\n        'affine:embed',\n        'affine:divider',\n        'affine:code',\n    ])) {\n        return false;\n    }\n    if (matchFlavours(model, ['affine:paragraph']) &&\n        ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'quote'].includes(model.type ?? '')) {\n        return false;\n    }\n    return true;\n}\nexport function isEmpty(model) {\n    if (model.children.length !== 0) {\n        const found = model.children.find(c => !isEmpty(c));\n        return !found;\n    }\n    return (!model.text?.length && !model.sourceId && model.flavour !== 'affine:code');\n}\nexport function almostEqual(a, b) {\n    return Math.abs(a - b) < 0.0001;\n}\nexport function createEvent(type, detail) {\n    return new CustomEvent(type, { detail });\n}\nexport function noop() {\n    return;\n}\nexport function throttle(fn, limit, { leading = true, trailing = true } = {}) {\n    let timer = null;\n    let lastArgs = null;\n    const setTimer = () => {\n        if (lastArgs && trailing) {\n            fn(...lastArgs);\n            lastArgs = null;\n            timer = setTimeout(setTimer, limit);\n        }\n        else {\n            timer = null;\n        }\n    };\n    return function (...args) {\n        if (timer) {\n            // in throttle\n            lastArgs = args;\n            return;\n        }\n        // Execute the function on the leading edge\n        if (leading) {\n            fn.apply(this, args);\n        }\n        timer = setTimeout(setTimer, limit);\n    };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const debounce = (fn, limit, { leading = true, trailing = true } = {}) => {\n    let timer = null;\n    let lastArgs = null;\n    const setTimer = () => {\n        if (lastArgs && trailing) {\n            fn(...lastArgs);\n            lastArgs = null;\n            timer = setTimeout(setTimer, limit);\n        }\n        else {\n            timer = null;\n        }\n    };\n    return function (...args) {\n        if (timer) {\n            lastArgs = args;\n            clearTimeout(timer);\n        }\n        if (leading && !timer) {\n            fn(...args);\n        }\n        timer = setTimeout(setTimer, limit);\n    };\n};\n/**\n * This function takes a value value, a minimum value min, and a maximum value max,\n * and returns the value of value clamped to the range [min, max].\n *\n * This means that if value is less than min, the function will return min;\n * if value is greater than max, the function will return max;\n * otherwise, the function will return value.\n *\n * @example\n * ```ts\n * const x = clamp(10, 0, 5); // x will be 5\n * const y = clamp(3, 0, 5); // y will be 3\n * const z = clamp(-1, 0, 5); // z will be 0\n * ```\n */\nexport const clamp = (value, min, max) => {\n    if (value < min) {\n        return min;\n    }\n    if (value > max) {\n        return max;\n    }\n    return value;\n};\n/**\n *\n * @example\n * ```ts\n * const items = [\n *  {name: 'a', classroom: 'c1'},\n *  {name: 'b', classroom: 'c2'},\n *  {name: 'a', classroom: 't0'}\n * ]\n * const counted = countBy(items1, i => i.name);\n * // counted: { a: 2, b: 1}\n * ```\n */\nexport function countBy(items, key) {\n    const count = {};\n    items.forEach(item => {\n        const k = key(item);\n        if (!count[k]) {\n            count[k] = 0;\n        }\n        count[k] += 1;\n    });\n    return count;\n}\n/**\n * @example\n * ```ts\n * const items = [{n: 1}, {n: 2}]\n * const max = maxBy(items, i => i.n);\n * // max: {n: 2}\n * ```\n */\nexport function maxBy(items, value) {\n    if (!items.length) {\n        return null;\n    }\n    let maxItem = items[0];\n    let max = value(maxItem);\n    for (let i = 1; i < items.length; i++) {\n        const item = items[i];\n        const v = value(item);\n        if (v > max) {\n            max = v;\n            maxItem = item;\n        }\n    }\n    return maxItem;\n}\nexport function isControlledKeyboardEvent(e) {\n    return e.ctrlKey || e.metaKey || e.altKey;\n}\nexport function isPrintableKeyEvent(event) {\n    return event.key.length === 1 && !isControlledKeyboardEvent(event);\n}\n/**\n * Checks if there are at least `n` elements in the array that match the given condition.\n *\n * @param arr - The input array of elements.\n * @param matchFn - A function that takes an element of the array and returns a boolean value\n *                  indicating if the element matches the desired condition.\n * @param n - The minimum number of matching elements required.\n * @returns A boolean value indicating if there are at least `n` matching elements in the array.\n *\n * @example\n * const arr = [1, 2, 3, 4, 5];\n * const isEven = (num: number): boolean => num % 2 === 0;\n * console.log(atLeastNMatches(arr, isEven, 2)); // Output: true\n */\nexport function atLeastNMatches(arr, matchFn, n) {\n    let count = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (matchFn(arr[i])) {\n            count++;\n            if (count >= n) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n/**\n * Groups an array of elements based on a provided key function.\n *\n * @example\n * interface Student {\n *   name: string;\n *   age: number;\n * }\n * const students: Student[] = [\n *   { name: 'Alice', age: 25 },\n *   { name: 'Bob', age: 23 },\n *   { name: 'Cathy', age: 25 },\n * ];\n * const groupedByAge = groupBy(students, (student) => student.age.toString());\n * console.log(groupedByAge);\n * // Output: {\n *  '23': [ { name: 'Bob', age: 23 } ],\n *  '25': [ { name: 'Alice', age: 25 }, { name: 'Cathy', age: 25 } ]\n * }\n */\nexport function groupBy(arr, key) {\n    const result = {};\n    for (const item of arr) {\n        const groupKey = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (typeof key === 'function' ? key(item) : item[key]);\n        if (!result[groupKey]) {\n            result[groupKey] = [];\n        }\n        result[groupKey].push(item);\n    }\n    return result;\n}\nfunction escapeRegExp(input) {\n    // escape regex characters in the input string to prevent regex format errors\n    return input.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n/**\n * Checks if the name is a fuzzy match of the query.\n *\n * @example\n * ```ts\n * const name = 'John Smith';\n * const query = 'js';\n * const isMatch = isFuzzyMatch(name, query);\n * // isMatch: true\n * ```\n */\nexport function isFuzzyMatch(name, query) {\n    const pureName = name\n        .trim()\n        .toLowerCase()\n        .split('')\n        .filter(char => char !== ' ')\n        .join('');\n    const regex = new RegExp(query\n        .split('')\n        .filter(char => char !== ' ')\n        .map(item => `${escapeRegExp(item)}.*`)\n        .join(''), 'i');\n    return regex.test(pureName);\n}\nexport function toHex(color) {\n    let r, g, b;\n    if (color.startsWith('#')) {\n        color = color.substr(1);\n        if (color.length === 3) {\n            color = color.replace(/./g, '$&$&');\n        }\n        [r, g, b] = color.match(/.{2}/g)?.map(hex => parseInt(hex, 16)) ?? [];\n    }\n    else if (color.startsWith('rgba')) {\n        [r, g, b] = color.match(/\\d+/g)?.map(Number) ?? [];\n    }\n    else if (color.startsWith('rgb')) {\n        [r, g, b] = color.match(/\\d+/g)?.map(Number) ?? [];\n    }\n    else {\n        throw new Error('Invalid color format');\n    }\n    if (r === undefined || g === undefined || b === undefined) {\n        throw new Error('Invalid color format');\n    }\n    const hex = ((r << 16) | (g << 8) | b).toString(16);\n    return '#' + '0'.repeat(6 - hex.length) + hex;\n}\nexport function capitalize(s) {\n    if (!s.length) {\n        return s;\n    }\n    return s[0].toUpperCase() + s.slice(1);\n}\nexport function uncapitalize(s) {\n    if (!s.length) {\n        return s;\n    }\n    return s[0].toLowerCase() + s.slice(1);\n}\n//# sourceMappingURL=std.js.map","import { DisposableGroup, } from '@blocksuite/store';\nexport var BrushSize;\n(function (BrushSize) {\n    BrushSize[BrushSize[\"Thin\"] = 4] = \"Thin\";\n    BrushSize[BrushSize[\"Thick\"] = 10] = \"Thick\";\n})(BrushSize || (BrushSize = {}));\nexport class AbstractSelectionManager {\n    constructor(container, dispatcher) {\n        this._disposables = new DisposableGroup();\n        this.container = container;\n        this._dispatcher = dispatcher;\n    }\n    get page() {\n        return this.container.page;\n    }\n}\n//# sourceMappingURL=types.js.map","export const ZERO_WIDTH_SPACE = '\\u200B';\n// see https://en.wikipedia.org/wiki/Zero-width_non-joiner\nexport const ZERO_WIDTH_NON_JOINER = '\\u200C';\n//# sourceMappingURL=consts.js.map","import { html } from 'lit';\nimport { styleMap } from 'lit/directives/style-map.js';\nfunction virgoTextStyles(props) {\n    let textDecorations = '';\n    if (props.underline) {\n        textDecorations += 'underline';\n    }\n    if (props.strike) {\n        textDecorations += ' line-through';\n    }\n    let inlineCodeStyle = {};\n    if (props.code) {\n        inlineCodeStyle = {\n            'font-family': '\"SFMono-Regular\", Menlo, Consolas, \"PT Mono\", \"Liberation Mono\", Courier, monospace',\n            'line-height': 'normal',\n            background: 'rgba(135,131,120,0.15)',\n            color: '#EB5757',\n            'border-radius': '3px',\n            'font-size': '85%',\n            padding: '0.2em 0.4em',\n        };\n    }\n    return styleMap({\n        'word-wrap': 'break-word',\n        'white-space': 'break-spaces',\n        'font-weight': props.bold ? 'bold' : 'normal',\n        'font-style': props.italic ? 'italic' : 'normal',\n        'text-decoration': textDecorations.length > 0 ? textDecorations : 'none',\n        ...inlineCodeStyle,\n    });\n}\nexport const getDefaultAttributeRenderer = () => delta => {\n    const style = delta.attributes\n        ? virgoTextStyles(delta.attributes)\n        : styleMap({});\n    return html `<span style=${style}\n      ><v-text .str=${delta.insert}></v-text\n    ></span>`;\n};\n//# sourceMappingURL=attribute-renderer.js.map","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { html, LitElement } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport { ZERO_WIDTH_SPACE } from '../consts.js';\nimport { getDefaultAttributeRenderer } from '../utils/attribute-renderer.js';\nlet VirgoElement = class VirgoElement extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.delta = {\n            insert: ZERO_WIDTH_SPACE,\n        };\n        this.attributeRenderer = getDefaultAttributeRenderer();\n    }\n    render() {\n        // we need to avoid \\n appearing before and after the span element, which will\n        // cause the unexpected space\n        return html `<span data-virgo-element=\"true\"\n      >${this.attributeRenderer(this.delta)}</span\n    >`;\n    }\n    createRenderRoot() {\n        return this;\n    }\n};\n__decorate([\n    property({ type: Object })\n], VirgoElement.prototype, \"delta\", void 0);\n__decorate([\n    property({ type: Function, attribute: false })\n], VirgoElement.prototype, \"attributeRenderer\", void 0);\nVirgoElement = __decorate([\n    customElement('v-element')\n], VirgoElement);\nexport { VirgoElement };\n//# sourceMappingURL=virgo-element.js.map","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { html, LitElement } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport { ZERO_WIDTH_SPACE } from '../consts.js';\nlet VirgoLine = class VirgoLine extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.elements = [];\n    }\n    get vElements() {\n        return Array.from(this.querySelectorAll('v-element'));\n    }\n    get textLength() {\n        return this.vElements.reduce((acc, el) => acc + el.delta.insert.length, 0);\n    }\n    get textContent() {\n        return this.vElements.reduce((acc, el) => acc + el.delta.insert, '');\n    }\n    async getUpdateComplete() {\n        const result = await super.getUpdateComplete();\n        await Promise.all(this.vElements.map(el => el.updateComplete));\n        return result;\n    }\n    firstUpdated() {\n        this.style.display = 'block';\n    }\n    render() {\n        if (this.elements.length === 0) {\n            return html `<div><v-text .str=${ZERO_WIDTH_SPACE}></v-text></div>`;\n        }\n        return html `<div>${this.elements}</div>`;\n    }\n    createRenderRoot() {\n        return this;\n    }\n};\n__decorate([\n    property({ attribute: false })\n], VirgoLine.prototype, \"elements\", void 0);\nVirgoLine = __decorate([\n    customElement('v-line')\n], VirgoLine);\nexport { VirgoLine };\n//# sourceMappingURL=virgo-line.js.map","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { html, LitElement } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport { styleMap } from 'lit/directives/style-map.js';\nimport { ZERO_WIDTH_SPACE } from '../consts.js';\nlet VText = class VText extends LitElement {\n    constructor() {\n        super(...arguments);\n        this.str = ZERO_WIDTH_SPACE;\n        this.styles = styleMap({\n            'word-wrap': 'break-word',\n            'white-space': 'break-spaces',\n        });\n    }\n    render() {\n        // we need to avoid \\n appearing before and after the span element, which will\n        // cause the sync problem about the cursor position\n        return html `<span style=${this.styles} data-virgo-text=\"true\"\n      >${this.str}</span\n    >`;\n    }\n    createRenderRoot() {\n        return this;\n    }\n};\n__decorate([\n    property()\n], VText.prototype, \"str\", void 0);\n__decorate([\n    property()\n], VText.prototype, \"styles\", void 0);\nVText = __decorate([\n    customElement('v-text')\n], VText);\nexport { VText };\n//# sourceMappingURL=virgo-text.js.map","export * from './virgo-element.js';\nexport * from './virgo-line.js';\nexport * from './virgo-text.js';\n//# sourceMappingURL=index.js.map","import { z } from 'zod';\nexport const baseTextAttributes = z.object({\n    bold: z.literal(true).optional().catch(undefined),\n    italic: z.literal(true).optional().catch(undefined),\n    underline: z.literal(true).optional().catch(undefined),\n    strike: z.literal(true).optional().catch(undefined),\n    code: z.literal(true).optional().catch(undefined),\n    link: z.string().optional().catch(undefined),\n});\n//# sourceMappingURL=base-attributes.js.map","export function transformDelta(delta) {\n    const result = [];\n    let tmpString = delta.insert;\n    while (tmpString.length > 0) {\n        const index = tmpString.indexOf('\\n');\n        if (index === -1) {\n            result.push({\n                insert: tmpString,\n                attributes: delta.attributes,\n            });\n            break;\n        }\n        if (tmpString.slice(0, index).length > 0) {\n            result.push({\n                insert: tmpString.slice(0, index),\n                attributes: delta.attributes,\n            });\n        }\n        result.push('\\n');\n        tmpString = tmpString.slice(index + 1);\n    }\n    return result;\n}\n/**\n * convert a delta insert array to chunks, each chunk is a line\n */\nexport function deltaInsertsToChunks(delta) {\n    if (delta.length === 0) {\n        return [[]];\n    }\n    const transformedDelta = delta.flatMap(transformDelta);\n    function* chunksGenerator(arr) {\n        let start = 0;\n        for (let i = 0; i < arr.length; i++) {\n            if (arr[i] === '\\n') {\n                const chunk = arr.slice(start, i);\n                start = i + 1;\n                yield chunk;\n            }\n            else if (i === arr.length - 1) {\n                yield arr.slice(start);\n            }\n        }\n        if (arr.at(-1) === '\\n') {\n            yield [];\n        }\n    }\n    return [...chunksGenerator(transformedDelta)];\n}\n//# sourceMappingURL=delta-convert.js.map","import { VirgoLine } from '../components/index.js';\nexport function isVText(text) {\n    return (text instanceof Text &&\n        (text.parentElement?.dataset.virgoText === 'true' ?? false));\n}\nexport function isVElement(element) {\n    return (element instanceof HTMLElement && element.dataset.virgoElement === 'true');\n}\nexport function isVLine(element) {\n    return (element instanceof HTMLElement &&\n        (element instanceof VirgoLine || element.parentElement instanceof VirgoLine));\n}\nexport function isVRoot(element) {\n    return element instanceof HTMLElement && element.dataset.virgoRoot === 'true';\n}\n//# sourceMappingURL=guard.js.map","import { ZERO_WIDTH_SPACE } from '../consts.js';\nexport function calculateTextLength(text) {\n    if (text.wholeText === ZERO_WIDTH_SPACE) {\n        return 0;\n    }\n    else {\n        return text.wholeText.length;\n    }\n}\nexport function getTextNodesFromElement(element) {\n    const textSpanElements = Array.from(element.querySelectorAll('[data-virgo-text=\"true\"]'));\n    const textNodes = textSpanElements.map(textSpanElement => {\n        const textNode = Array.from(textSpanElement.childNodes).find((node) => node instanceof Text);\n        if (!textNode) {\n            throw new Error('text node not found');\n        }\n        return textNode;\n    });\n    return textNodes;\n}\n//# sourceMappingURL=text.js.map","import { ZERO_WIDTH_SPACE } from '../consts.js';\nimport { isVElement, isVLine, isVRoot, isVText } from './guard.js';\nimport { calculateTextLength, getTextNodesFromElement } from './text.js';\nexport function nativePointToTextPoint(node, offset) {\n    if (isVText(node)) {\n        return [node, offset];\n    }\n    if (isVElement(node)) {\n        const texts = getTextNodesFromElement(node);\n        let textOffset = offset;\n        for (const text of texts) {\n            if (offset <= text.length) {\n                return [text, textOffset];\n            }\n            textOffset -= text.length;\n        }\n        return null;\n    }\n    if (isVLine(node) || isVRoot(node)) {\n        return getTextPointFromElementByOffset(node, offset, true);\n    }\n    if (!(node instanceof Node)) {\n        return null;\n    }\n    const vNodes = getVNodesFromNode(node);\n    if (vNodes) {\n        return getTextPointFromVNodes(vNodes, node, offset);\n    }\n    return null;\n}\nexport function textPointToDomPoint(text, offset, rootElement) {\n    if (rootElement.dataset.virgoRoot !== 'true') {\n        throw new Error('textRangeToDomPoint should be called with editor root element');\n    }\n    if (!rootElement.contains(text)) {\n        return null;\n    }\n    const texts = getTextNodesFromElement(rootElement);\n    const goalIndex = texts.indexOf(text);\n    let index = 0;\n    for (const text of texts.slice(0, goalIndex)) {\n        index += calculateTextLength(text);\n    }\n    if (text.wholeText !== ZERO_WIDTH_SPACE) {\n        index += offset;\n    }\n    const textParentElement = text.parentElement;\n    if (!textParentElement) {\n        throw new Error('text element parent not found');\n    }\n    const lineElement = textParentElement.closest('v-line');\n    if (!lineElement) {\n        throw new Error('line element not found');\n    }\n    const lineIndex = Array.from(rootElement.querySelectorAll('v-line')).indexOf(lineElement);\n    return { text, index: index + lineIndex };\n}\nfunction getVNodesFromNode(node) {\n    const vLine = node.parentElement?.closest('v-line');\n    if (vLine) {\n        return Array.from(vLine.querySelectorAll('v-element'));\n    }\n    const container = node instanceof Element\n        ? node.closest('[data-virgo-root=\"true\"]')\n        : node.parentElement?.closest('[data-virgo-root=\"true\"]');\n    if (container) {\n        return Array.from(container.querySelectorAll('v-line'));\n    }\n    return null;\n}\nfunction getTextPointFromVNodes(vNodes, node, offset) {\n    const first = vNodes[0];\n    for (let i = 0; i < vNodes.length; i++) {\n        const vLine = vNodes[i];\n        if (i === 0 && AFollowedByB(node, vLine)) {\n            return getTextPointFromElementByOffset(first, offset, true);\n        }\n        if (AInsideB(node, vLine)) {\n            return getTextPointFromElementByOffset(first, offset, false);\n        }\n        if (i === vNodes.length - 1 && APrecededByB(node, vLine)) {\n            return getTextPointFromElement(vLine);\n        }\n        if (i < vNodes.length - 1 &&\n            APrecededByB(node, vLine) &&\n            AFollowedByB(node, vNodes[i + 1])) {\n            return getTextPointFromElement(vLine);\n        }\n    }\n    return null;\n}\nfunction getTextPointFromElement(element) {\n    const texts = getTextNodesFromElement(element);\n    if (texts.length === 0)\n        return null;\n    const text = texts[texts.length - 1];\n    return [text, calculateTextLength(text)];\n}\nfunction getTextPointFromElementByOffset(element, offset, fromStart) {\n    const texts = getTextNodesFromElement(element);\n    if (texts.length === 0)\n        return null;\n    const text = fromStart ? texts[0] : texts[texts.length - 1];\n    return [text, offset === 0 ? offset : text.length];\n}\nfunction AInsideB(a, b) {\n    return (b.compareDocumentPosition(a) === Node.DOCUMENT_POSITION_CONTAINED_BY ||\n        b.compareDocumentPosition(a) ===\n            (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING));\n}\nfunction AFollowedByB(a, b) {\n    return a.compareDocumentPosition(b) === Node.DOCUMENT_POSITION_FOLLOWING;\n}\nfunction APrecededByB(a, b) {\n    return a.compareDocumentPosition(b) === Node.DOCUMENT_POSITION_PRECEDING;\n}\n//# sourceMappingURL=point-conversion.js.map","export function findDocumentOrShadowRoot(editor) {\n    const el = editor.rootElement;\n    if (!el) {\n        throw new Error('editor root element not found');\n    }\n    const root = el.getRootNode();\n    if ((root instanceof Document || root instanceof ShadowRoot) &&\n        'getSelection' in root) {\n        return root;\n    }\n    return el.ownerDocument;\n}\n//# sourceMappingURL=query.js.map","export function isSelectionBackwards(selection) {\n    let backwards = false;\n    if (!selection.isCollapsed && selection.anchorNode && selection.focusNode) {\n        const range = document.createRange();\n        range.setStart(selection.anchorNode, selection.anchorOffset);\n        range.setEnd(selection.focusNode, selection.focusOffset);\n        backwards = range.collapsed;\n        range.detach();\n    }\n    return backwards;\n}\n//# sourceMappingURL=selection.js.map","import { nativePointToTextPoint, textPointToDomPoint, } from './point-conversion.js';\nimport { isSelectionBackwards } from './selection.js';\nimport { calculateTextLength, getTextNodesFromElement } from './text.js';\nconst rangeHasAnchorAndFocus = ({ rootElement, anchorText, focusText, }) => {\n    return rootElement.contains(anchorText) && rootElement.contains(focusText);\n};\nconst rangeHasAnchorAndFocusHandler = ({ rootElement, anchorText, focusText, anchorTextOffset, focusTextOffset, }) => {\n    const anchorDomPoint = textPointToDomPoint(anchorText, anchorTextOffset, rootElement);\n    const focusDomPoint = textPointToDomPoint(focusText, focusTextOffset, rootElement);\n    if (!anchorDomPoint || !focusDomPoint) {\n        return null;\n    }\n    return {\n        index: Math.min(anchorDomPoint.index, focusDomPoint.index),\n        length: Math.abs(anchorDomPoint.index - focusDomPoint.index),\n    };\n};\nconst rangeOnlyHasFocus = ({ rootElement, anchorText, focusText }) => {\n    return !rootElement.contains(anchorText) && rootElement.contains(focusText);\n};\nconst rangeOnlyHasFocusHandler = ({ selection, yText, rootElement, anchorText, focusText, anchorTextOffset, focusTextOffset, }) => {\n    if (isSelectionBackwards(selection)) {\n        const anchorDomPoint = textPointToDomPoint(anchorText, anchorTextOffset, rootElement);\n        if (!anchorDomPoint) {\n            return null;\n        }\n        return {\n            index: anchorDomPoint.index,\n            length: yText.length - anchorDomPoint.index,\n        };\n    }\n    else {\n        const focusDomPoint = textPointToDomPoint(focusText, focusTextOffset, rootElement);\n        if (!focusDomPoint) {\n            return null;\n        }\n        return {\n            index: 0,\n            length: focusDomPoint.index,\n        };\n    }\n};\nconst rangeOnlyHasAnchor = ({ rootElement, anchorText, focusText, }) => {\n    return rootElement.contains(anchorText) && !rootElement.contains(focusText);\n};\nconst rangeOnlyHasAnchorHandler = ({ selection, yText, rootElement, anchorText, focusText, anchorTextOffset, focusTextOffset, }) => {\n    if (isSelectionBackwards(selection)) {\n        const focusDomPoint = textPointToDomPoint(focusText, focusTextOffset, rootElement);\n        if (!focusDomPoint) {\n            return null;\n        }\n        return {\n            index: 0,\n            length: focusDomPoint.index,\n        };\n    }\n    else {\n        const anchorDomPoint = textPointToDomPoint(anchorText, anchorTextOffset, rootElement);\n        if (!anchorDomPoint) {\n            return null;\n        }\n        return {\n            index: anchorDomPoint.index,\n            length: yText.length - anchorDomPoint.index,\n        };\n    }\n};\nconst rangeHasNoAnchorAndFocus = ({ rootElement, anchorText, focusText, }) => {\n    return !rootElement.contains(anchorText) && !rootElement.contains(focusText);\n};\nconst rangeHasNoAnchorAndFocusHandler = ({ yText }) => {\n    return {\n        index: 0,\n        length: yText.length,\n    };\n};\nconst buildContext = (selection, rootElement, yText) => {\n    const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;\n    const anchorTextPoint = nativePointToTextPoint(anchorNode, anchorOffset);\n    const focusTextPoint = nativePointToTextPoint(focusNode, focusOffset);\n    if (!anchorTextPoint || !focusTextPoint) {\n        return null;\n    }\n    const [anchorText, anchorTextOffset] = anchorTextPoint;\n    const [focusText, focusTextOffset] = focusTextPoint;\n    return {\n        rootElement,\n        selection,\n        yText,\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset,\n        anchorText,\n        anchorTextOffset,\n        focusText,\n        focusTextOffset,\n    };\n};\n/**\n * calculate the vRange from dom selection for **this Editor**\n * there are three cases when the vRange of this Editor is not null:\n * (In the following, \"|\" mean anchor and focus, each line is a separate Editor)\n * 1. anchor and focus are in this Editor\n *    aaaaaa\n *    b|bbbb|b\n *    cccccc\n *    the vRange of second Editor is {index: 1, length: 4}, the others are null\n * 2. anchor and focus one in this Editor, one in another Editor\n *    aaa|aaa    aaaaaa\n *    bbbbb|b or bbbbb|b\n *    cccccc     cc|cccc\n *    2.1\n *        the vRange of first Editor is {index: 3, length: 3}, the second is {index: 0, length: 5},\n *        the third is null\n *    2.2\n *        the vRange of first Editor is null, the second is {index: 5, length: 1},\n *        the third is {index: 0, length: 2}\n * 3. anchor and focus are in another Editor\n *    aa|aaaa\n *    bbbbbb\n *    cccc|cc\n *    the vRange of first Editor is {index: 2, length: 4},\n *    the second is {index: 0, length: 6}, the third is {index: 0, length: 4}\n */\nexport function domRangeToVirgoRange(selection, rootElement, yText) {\n    const context = buildContext(selection, rootElement, yText);\n    if (!context)\n        return null;\n    // case 1\n    if (rangeHasAnchorAndFocus(context)) {\n        return rangeHasAnchorAndFocusHandler(context);\n    }\n    // case 2.1\n    if (rangeOnlyHasFocus(context)) {\n        return rangeOnlyHasFocusHandler(context);\n    }\n    // case 2.2\n    if (rangeOnlyHasAnchor(context)) {\n        return rangeOnlyHasAnchorHandler(context);\n    }\n    // case 3\n    if (rangeHasNoAnchorAndFocus(context)) {\n        return rangeHasNoAnchorAndFocusHandler(context);\n    }\n    return null;\n}\n/**\n * calculate the dom selection from vRange for **this Editor**\n */\nexport function virgoRangeToDomRange(rootElement, vRange) {\n    const lineElements = Array.from(rootElement.querySelectorAll('v-line'));\n    // calculate anchorNode and focusNode\n    let anchorText = null;\n    let focusText = null;\n    let anchorOffset = 0;\n    let focusOffset = 0;\n    let index = 0;\n    for (let i = 0; i < lineElements.length; i++) {\n        if (anchorText && focusText) {\n            break;\n        }\n        const texts = getTextNodesFromElement(lineElements[i]);\n        for (const text of texts) {\n            const textLength = calculateTextLength(text);\n            if (!anchorText && index + textLength >= vRange.index) {\n                anchorText = text;\n                anchorOffset = vRange.index - index;\n            }\n            if (!focusText && index + textLength >= vRange.index + vRange.length) {\n                focusText = text;\n                focusOffset = vRange.index + vRange.length - index;\n            }\n            if (anchorText && focusText) {\n                break;\n            }\n            index += textLength;\n        }\n        // the one because of the line break\n        index += 1;\n    }\n    if (!anchorText || !focusText) {\n        return null;\n    }\n    const range = document.createRange();\n    range.setStart(anchorText, anchorOffset);\n    range.setEnd(focusText, focusOffset);\n    return range;\n}\n//# sourceMappingURL=range-conversion.js.map","import { html } from 'lit';\nexport function renderElement(delta, parseAttributes, attributeRenderer) {\n    return html `<v-element\n    .delta=${{\n        insert: delta.insert,\n        attributes: parseAttributes(delta.attributes),\n    }}\n    .attributeRenderer=${attributeRenderer}\n  ></v-element>`;\n}\n//# sourceMappingURL=renderer.js.map","export * from './attribute-renderer.js';\nexport * from './base-attributes.js';\nexport * from './delta-convert.js';\nexport * from './guard.js';\nexport * from './point-conversion.js';\nexport * from './query.js';\nexport * from './range-conversion.js';\nexport * from './renderer.js';\nexport * from './selection.js';\nexport * from './text.js';\nexport * from './transform-input.js';\n//# sourceMappingURL=index.js.map","import { baseTextAttributes, getDefaultAttributeRenderer, } from '../utils/index.js';\nexport class VirgoAttributeService {\n    constructor(editor) {\n        this._marks = null;\n        this._attributeRenderer = getDefaultAttributeRenderer();\n        this._attributeSchema = baseTextAttributes;\n        this.setMarks = (marks) => {\n            this._marks = marks;\n        };\n        this.resetMarks = () => {\n            this._marks = null;\n        };\n        this.setAttributeSchema = (schema) => {\n            this._attributeSchema = schema;\n        };\n        this.setAttributeRenderer = (renderer) => {\n            this._attributeRenderer = renderer;\n        };\n        this.getFormat = (vRange, loose = false) => {\n            const deltas = this._editor.deltaService\n                .getDeltasByVRange(vRange)\n                .filter(([delta, position]) => position.index + position.length > vRange.index &&\n                position.index <= vRange.index + vRange.length);\n            const maybeAttributesList = deltas.map(([delta]) => delta.attributes);\n            if (loose) {\n                return maybeAttributesList.reduce((acc, cur) => ({ ...acc, ...cur }), {});\n            }\n            if (!maybeAttributesList.length ||\n                // some text does not have any attribute\n                maybeAttributesList.some(attributes => !attributes)) {\n                return {};\n            }\n            const attributesList = maybeAttributesList;\n            return attributesList.reduce((acc, cur) => {\n                const newFormat = {};\n                for (const key in acc) {\n                    const typedKey = key;\n                    // If the given range contains multiple different formats\n                    // such as links with different values,\n                    // we will treat it as having no format\n                    if (acc[typedKey] === cur[typedKey]) {\n                        // This cast is secure because we have checked that the value of the key is the same.\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        newFormat[typedKey] = acc[typedKey];\n                    }\n                }\n                return newFormat;\n            });\n        };\n        this.normalizeAttributes = (textAttributes) => {\n            if (!textAttributes) {\n                return undefined;\n            }\n            const attributeResult = this._attributeSchema.safeParse(textAttributes);\n            if (!attributeResult.success) {\n                console.error(attributeResult.error);\n                return undefined;\n            }\n            return Object.fromEntries(\n            // filter out undefined values\n            Object.entries(attributeResult.data).filter(([k, v]) => v));\n        };\n        this._editor = editor;\n    }\n    get marks() {\n        return this._marks;\n    }\n    get attributeRenderer() {\n        return this._attributeRenderer;\n    }\n}\n//# sourceMappingURL=attribute.js.map","import { html, render } from 'lit';\nimport { repeat } from 'lit/directives/repeat.js';\nimport { deltaInsertsToChunks, renderElement } from '../utils/index.js';\nexport class VirgoDeltaService {\n    constructor(editor) {\n        this.mapDeltasInVRange = (vRange, callback) => {\n            const deltas = this.deltas;\n            const result = [];\n            deltas.reduce((index, delta) => {\n                const length = delta.insert.length;\n                const from = vRange.index - length;\n                const to = vRange.index + vRange.length;\n                const deltaInRange = index >= from &&\n                    (index < to || (vRange.length === 0 && index === vRange.index));\n                if (deltaInRange) {\n                    const value = callback(delta, index);\n                    result.push(value);\n                }\n                return index + length;\n            }, 0);\n            return result;\n        };\n        /**\n         * Here are examples of how this function computes and gets the delta.\n         *\n         * We have such a text:\n         * ```\n         * [\n         *   {\n         *      insert: 'aaa',\n         *      attributes: { bold: true },\n         *   },\n         *   {\n         *      insert: 'bbb',\n         *      attributes: { italic: true },\n         *   },\n         * ]\n         * ```\n         *\n         * `getDeltaByRangeIndex(0)` returns `{ insert: 'aaa', attributes: { bold: true } }`.\n         *\n         * `getDeltaByRangeIndex(1)` returns `{ insert: 'aaa', attributes: { bold: true } }`.\n         *\n         * `getDeltaByRangeIndex(3)` returns `{ insert: 'aaa', attributes: { bold: true } }`.\n         *\n         * `getDeltaByRangeIndex(4)` returns `{ insert: 'bbb', attributes: { italic: true } }`.\n         */\n        this.getDeltaByRangeIndex = (rangeIndex) => {\n            const deltas = this.deltas;\n            let index = 0;\n            for (const delta of deltas) {\n                if (index + delta.insert.length >= rangeIndex) {\n                    return delta;\n                }\n                index += delta.insert.length;\n            }\n            return null;\n        };\n        /**\n         * Here are examples of how this function computes and gets the deltas.\n         *\n         * We have such a text:\n         * ```\n         * [\n         *   {\n         *      insert: 'aaa',\n         *      attributes: { bold: true },\n         *   },\n         *   {\n         *      insert: 'bbb',\n         *      attributes: { italic: true },\n         *   },\n         *   {\n         *      insert: 'ccc',\n         *      attributes: { underline: true },\n         *   },\n         * ]\n         * ```\n         *\n         * `getDeltasByVRange({ index: 0, length: 0 })` returns\n         * ```\n         * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }]]\n         * ```\n         *\n         * `getDeltasByVRange({ index: 0, length: 1 })` returns\n         * ```\n         * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }]]\n         * ```\n         *\n         * `getDeltasByVRange({ index: 0, length: 4 })` returns\n         * ```\n         * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }],\n         *  [{ insert: 'bbb', attributes: { italic: true }, }, { index: 3, length: 3, }]]\n         * ```\n         *\n         * `getDeltasByVRange({ index: 3, length: 1 })` returns\n         * ```\n         * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }],\n         *  [{ insert: 'bbb', attributes: { italic: true }, }, { index: 3, length: 3, }]]\n         * ```\n         *\n         * `getDeltasByVRange({ index: 3, length: 3 })` returns\n         * ```\n         * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }],\n         *  [{ insert: 'bbb', attributes: { italic: true }, }, { index: 3, length: 3, }]]\n         * ```\n         *\n         *  `getDeltasByVRange({ index: 3, length: 4 })` returns\n         * ```\n         * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }],\n         *  [{ insert: 'bbb', attributes: { italic: true }, }, { index: 3, length: 3, }],\n         *  [{ insert: 'ccc', attributes: { underline: true }, }, { index: 6, length: 3, }]]\n         * ```\n         */\n        this.getDeltasByVRange = (vRange) => {\n            return this.mapDeltasInVRange(vRange, (delta, index) => [\n                delta,\n                { index, length: delta.insert.length },\n            ]);\n        };\n        // render current deltas to VLines\n        this.render = async () => {\n            const rootElement = this._editor.rootElement;\n            const deltas = this.deltas;\n            const chunks = deltaInsertsToChunks(deltas);\n            // every chunk is a line\n            const lines = chunks.map(chunk => {\n                const elementTs = [];\n                if (chunk.length > 0) {\n                    chunk.forEach(delta => {\n                        const element = renderElement(delta, this._editor.attributeService.normalizeAttributes, this._editor.attributeService.attributeRenderer);\n                        elementTs.push(element);\n                    });\n                }\n                return html `<v-line .elements=${elementTs}></v-line>`;\n            });\n            try {\n                render(repeat(lines.map((line, i) => ({ line, index: i })), entry => entry.index, entry => entry.line), rootElement);\n            }\n            catch (error) {\n                // Lit may be crashed by IME input and we need to rerender whole editor for it\n                render(html `<div></div>`, rootElement);\n                this._editor.requestUpdate();\n            }\n            const vLines = Array.from(rootElement.querySelectorAll('v-line'));\n            await Promise.all(vLines.map(line => line.updateComplete));\n            // We need to synchronize the selection immediately after rendering is completed,\n            // otherwise there is a possibility of an error in the cursor position\n            this._editor.rangeService.syncVRange();\n            this._editor.slots.updated.emit();\n        };\n        this._editor = editor;\n    }\n    get deltas() {\n        return this._editor.yText.toDelta();\n    }\n}\n//# sourceMappingURL=delta.js.map","function handleInsertText(vRange, data, editor, attributes) {\n    if (vRange.index >= 0 && data) {\n        editor.slots.vRangeUpdated.emit([\n            {\n                index: vRange.index + data.length,\n                length: 0,\n            },\n            'input',\n        ]);\n        editor.insertText(vRange, data, attributes);\n    }\n}\nfunction handleInsertParagraph(vRange, editor) {\n    if (vRange.index >= 0) {\n        editor.slots.vRangeUpdated.emit([\n            {\n                index: vRange.index + 1,\n                length: 0,\n            },\n            'input',\n        ]);\n        editor.insertLineBreak(vRange);\n    }\n}\nfunction handleDelete(vRange, editor) {\n    if (vRange.index >= 0) {\n        if (vRange.length > 0) {\n            editor.slots.vRangeUpdated.emit([\n                {\n                    index: vRange.index,\n                    length: 0,\n                },\n                'input',\n            ]);\n            editor.deleteText(vRange);\n            return;\n        }\n        if (vRange.index > 0) {\n            const originalString = editor.yText.toString().slice(0, vRange.index);\n            const segments = [...new Intl.Segmenter().segment(originalString)];\n            const deletedLength = segments[segments.length - 1].segment.length;\n            editor.slots.vRangeUpdated.emit([\n                {\n                    index: vRange.index - deletedLength,\n                    length: 0,\n                },\n                'input',\n            ]);\n            editor.deleteText({\n                index: vRange.index - deletedLength,\n                length: deletedLength,\n            });\n        }\n    }\n}\nfunction handleWordDelete(editor, vRange) {\n    const matches = /\\S+\\s*$/.exec(editor.yText.toString().slice(0, vRange.index));\n    if (matches) {\n        const deleteLength = matches[0].length;\n        editor.slots.vRangeUpdated.emit([\n            {\n                index: vRange.index - deleteLength,\n                length: 0,\n            },\n            'input',\n        ]);\n        editor.deleteText({\n            index: vRange.index - deleteLength,\n            length: deleteLength,\n        });\n    }\n}\nfunction handleLineDelete(editor, vRange) {\n    if (vRange.length > 0) {\n        editor.slots.vRangeUpdated.emit([\n            {\n                index: vRange.index,\n                length: 0,\n            },\n            'input',\n        ]);\n        editor.deleteText(vRange);\n        return;\n    }\n    if (vRange.index > 0) {\n        const str = editor.yText.toString();\n        const deleteLength = vRange.index - Math.max(0, str.slice(0, vRange.index).lastIndexOf('\\n'));\n        editor.slots.vRangeUpdated.emit([\n            {\n                index: vRange.index - deleteLength,\n                length: 0,\n            },\n            'input',\n        ]);\n        editor.deleteText({\n            index: vRange.index - deleteLength,\n            length: deleteLength,\n        });\n    }\n}\nfunction handleForwardDelete(editor, vRange) {\n    if (vRange.index < editor.yText.length) {\n        const originalString = editor.yText.toString();\n        const segments = [...new Intl.Segmenter().segment(originalString)];\n        const slicedString = originalString.slice(0, vRange.index);\n        const slicedSegments = [...new Intl.Segmenter().segment(slicedString)];\n        const deletedLength = segments[slicedSegments.length].segment.length;\n        editor.slots.vRangeUpdated.emit([\n            {\n                index: vRange.index,\n                length: 0,\n            },\n            'input',\n        ]);\n        editor.deleteText({\n            index: vRange.index,\n            length: deletedLength,\n        });\n    }\n}\nexport function transformInput(inputType, data, attributes, vRange, editor) {\n    // You can find explanation of inputType here:\n    // [Input Events Level 2](https://w3c.github.io/input-events/#interface-InputEvent-Attributes)\n    switch (inputType) {\n        case 'insertText': {\n            handleInsertText(vRange, data, editor, attributes);\n            return;\n        }\n        case 'insertParagraph': {\n            handleInsertParagraph(vRange, editor);\n            return;\n        }\n        // Chrome and Safari on Mac: Backspace or Ctrl + H\n        case 'deleteContentBackward':\n        case 'deleteByCut': {\n            handleDelete(vRange, editor);\n            return;\n        }\n        // On Mac: Option + Backspace\n        // On iOS: Hold the backspace for a while and the whole words will start to disappear\n        case 'deleteWordBackward': {\n            handleWordDelete(editor, vRange);\n            return;\n        }\n        // deleteHardLineBackward: Safari on Mac: Cmd + Backspace\n        // deleteSoftLineBackward: Chrome on Mac: Cmd + Backspace\n        case 'deleteHardLineBackward':\n        case 'deleteSoftLineBackward': {\n            handleLineDelete(editor, vRange);\n            return;\n        }\n        // Chrome on Mac: Fn + Backspace or Ctrl + D\n        // Safari on Mac: Ctrl + K or Ctrl + D\n        case 'deleteContentForward': {\n            handleForwardDelete(editor, vRange);\n            return;\n        }\n    }\n}\n//# sourceMappingURL=transform-input.js.map","import { assertExists } from '@blocksuite/global/utils';\nimport { ZERO_WIDTH_SPACE } from '../consts.js';\nimport { findDocumentOrShadowRoot, } from '../utils/index.js';\nimport { transformInput } from '../utils/transform-input.js';\nexport class VirgoEventService {\n    constructor(editor) {\n        this._mountAbortController = null;\n        this._handlerAbortController = null;\n        this._isComposing = false;\n        this._handlers = {};\n        this._previousAnchor = null;\n        this._previousFocus = null;\n        this.defaultHandlers = {\n            paste: (event) => {\n                const data = event.clipboardData?.getData('text/plain');\n                if (data) {\n                    const vRange = this._editor.getVRange();\n                    const text = data.replace(/(\\r\\n|\\r|\\n)/g, '\\n');\n                    if (vRange) {\n                        this._editor.insertText(vRange, text);\n                        this._editor.setVRange({\n                            index: vRange.index + text.length,\n                            length: 0,\n                        });\n                    }\n                }\n            },\n        };\n        this.mount = () => {\n            const rootElement = this._editor.rootElement;\n            this._mountAbortController = new AbortController();\n            document.addEventListener('selectionchange', this._onSelectionChange);\n            const signal = this._mountAbortController.signal;\n            rootElement.addEventListener('beforeinput', this._onBeforeInput, {\n                signal,\n            });\n            rootElement\n                .querySelectorAll('[data-virgo-text=\"true\"]')\n                .forEach(textNode => {\n                textNode.addEventListener('dragstart', event => {\n                    event.preventDefault();\n                });\n            });\n            rootElement.addEventListener('compositionstart', this._onCompositionStart, {\n                signal,\n            });\n            rootElement.addEventListener('compositionend', this._onCompositionEnd, {\n                signal,\n            });\n            rootElement.addEventListener('scroll', this._onScroll);\n            this.bindHandlers();\n        };\n        this.unmount = () => {\n            document.removeEventListener('selectionchange', this._onSelectionChange);\n            if (this._mountAbortController) {\n                this._mountAbortController.abort();\n                this._mountAbortController = null;\n            }\n            if (this._handlerAbortController) {\n                this._handlerAbortController.abort();\n                this._handlerAbortController = null;\n            }\n            this._handlers = this.defaultHandlers;\n        };\n        this.bindHandlers = (handlers = this\n            .defaultHandlers) => {\n            this._handlers = handlers;\n            if (this._handlerAbortController) {\n                this._handlerAbortController.abort();\n            }\n            this._handlerAbortController = new AbortController();\n            if (this._handlers.paste) {\n                this._editor.rootElement.addEventListener('paste', this._handlers.paste, {\n                    signal: this._handlerAbortController.signal,\n                });\n            }\n            if (this._handlers.keydown) {\n                this._editor.rootElement.addEventListener('keydown', this._handlers.keydown, {\n                    signal: this._handlerAbortController.signal,\n                });\n            }\n        };\n        this._onSelectionChange = () => {\n            const rootElement = this._editor.rootElement;\n            if (this._isComposing) {\n                return;\n            }\n            const selectionRoot = findDocumentOrShadowRoot(this._editor);\n            const selection = selectionRoot.getSelection();\n            if (!selection)\n                return;\n            if (selection.rangeCount === 0)\n                return;\n            const range = selection.getRangeAt(0);\n            if (range.startContainer === range.endContainer &&\n                range.startContainer.textContent === ZERO_WIDTH_SPACE &&\n                range.startOffset === 1) {\n                range.setStart(range.startContainer, 0);\n                range.setEnd(range.endContainer, 0);\n                selection.removeAllRanges();\n                selection.addRange(range);\n                return;\n            }\n            if (!range)\n                return;\n            if (!range.intersectsNode(rootElement)) {\n                if (range.endContainer.contains(rootElement) &&\n                    Array.from(range.endContainer.childNodes).filter(node => node instanceof HTMLElement).length === 1 &&\n                    range.startContainer.contains(rootElement) &&\n                    Array.from(range.startContainer.childNodes).filter(node => node instanceof HTMLElement).length === 1) {\n                    this._editor.focusEnd();\n                }\n                else {\n                    return;\n                }\n            }\n            this._previousAnchor = [range.startContainer, range.startOffset];\n            this._previousFocus = [range.endContainer, range.endOffset];\n            const vRange = this._editor.toVRange(selection);\n            if (vRange) {\n                this._editor.slots.vRangeUpdated.emit([vRange, 'native']);\n            }\n            // avoid infinite syncVRange\n            if (((range.startContainer.nodeType !== Node.TEXT_NODE ||\n                range.endContainer.nodeType !== Node.TEXT_NODE) &&\n                range.startContainer !== this._previousAnchor[0] &&\n                range.endContainer !== this._previousFocus[0] &&\n                range.startOffset !== this._previousAnchor[1] &&\n                range.endOffset !== this._previousFocus[1]) ||\n                range.startContainer.nodeType === Node.COMMENT_NODE ||\n                range.endContainer.nodeType === Node.COMMENT_NODE) {\n                this._editor.syncVRange();\n            }\n        };\n        this._onCompositionStart = () => {\n            this._isComposing = true;\n        };\n        this._onCompositionEnd = (event) => {\n            this._isComposing = false;\n            if (this._editor.isReadonly)\n                return;\n            const vRange = this._editor.getVRange();\n            if (!vRange)\n                return;\n            let ctx = {\n                event,\n                data: event.data,\n                vRange,\n                skipDefault: false,\n                attributes: null,\n            };\n            if (this._handlers.virgoCompositionEnd) {\n                ctx = this._handlers.virgoCompositionEnd(ctx);\n            }\n            if (ctx.skipDefault)\n                return;\n            const { data, vRange: newVRange } = ctx;\n            if (newVRange.index >= 0) {\n                const selection = window.getSelection();\n                if (selection && selection.rangeCount !== 0) {\n                    const range = selection.getRangeAt(0);\n                    const container = range.startContainer;\n                    // https://github.com/w3c/input-events/issues/137\n                    // IME will directly modify the DOM and is difficult to hijack and cancel.\n                    // We need to delete this part of the content and restore the selection.\n                    if (container instanceof Text) {\n                        if (container.parentElement?.dataset.virgoText !== 'true') {\n                            container.remove();\n                        }\n                        else {\n                            const [text] = this._editor.getTextPoint(newVRange.index);\n                            const vText = text.parentElement?.closest('v-text');\n                            if (vText) {\n                                if (vText.str !== text.textContent) {\n                                    text.textContent = vText.str;\n                                }\n                            }\n                            else {\n                                const forgedVText = text.parentElement?.closest('[data-virgo-text=\"true\"]');\n                                if (forgedVText instanceof HTMLElement) {\n                                    if (forgedVText.dataset.virgoTextValue) {\n                                        if (forgedVText.dataset.virgoTextValue !== text.textContent) {\n                                            text.textContent = forgedVText.dataset.virgoTextValue;\n                                        }\n                                    }\n                                    else {\n                                        throw new Error('We detect a forged v-text node but it has no data-virgo-text-value attribute.');\n                                    }\n                                }\n                            }\n                        }\n                        const newRange = this._editor.toDomRange(newVRange);\n                        if (newRange) {\n                            assertExists(newRange);\n                            selection.removeAllRanges();\n                            selection.addRange(newRange);\n                        }\n                    }\n                }\n                if (data && data.length > 0) {\n                    this._editor.insertText(newVRange, data, ctx.attributes ?? {});\n                    this._editor.slots.vRangeUpdated.emit([\n                        {\n                            index: newVRange.index + data.length,\n                            length: 0,\n                        },\n                        'input',\n                    ]);\n                }\n            }\n        };\n        this._firstRecomputeInFrame = true;\n        this._onBeforeInput = (event) => {\n            event.preventDefault();\n            if (this._editor.isReadonly || this._isComposing)\n                return;\n            if (this._firstRecomputeInFrame) {\n                this._firstRecomputeInFrame = false;\n                this._onSelectionChange();\n                requestAnimationFrame(() => {\n                    this._firstRecomputeInFrame = true;\n                });\n            }\n            const vRange = this._editor.getVRange();\n            if (!vRange)\n                return;\n            let ctx = {\n                event,\n                data: event.data,\n                vRange,\n                skipDefault: false,\n                attributes: null,\n            };\n            if (this._handlers.virgoInput) {\n                ctx = this._handlers.virgoInput(ctx);\n            }\n            if (ctx.skipDefault)\n                return;\n            const { event: newEvent, data, vRange: newVRange } = ctx;\n            transformInput(newEvent.inputType, data, ctx.attributes ?? {}, newVRange, this._editor);\n        };\n        this._onScroll = (event) => {\n            this._editor.slots.scrollUpdated.emit(this._editor.rootElement.scrollLeft);\n        };\n        this._editor = editor;\n    }\n}\n//# sourceMappingURL=event.js.map","import { VirgoLine } from '../components/index.js';\nimport { domRangeToVirgoRange, findDocumentOrShadowRoot, virgoRangeToDomRange, } from '../utils/index.js';\nexport class VirgoRangeService {\n    constructor(editor) {\n        this._vRange = null;\n        this._lastScrollLeft = 0;\n        this.onVRangeUpdated = ([newVRange, origin]) => {\n            this._vRange = newVRange;\n            document.dispatchEvent(new CustomEvent('virgo-vrange-updated'));\n            if (origin !== 'other') {\n                return;\n            }\n            const fn = () => {\n                // There may be multiple range update events in one frame,\n                // so we need to obtain the latest vRange.\n                // see https://github.com/toeverything/blocksuite/issues/2982\n                if (this._vRange) {\n                    // when using input method _vRange will return to the starting point,\n                    // so we need to re-sync\n                    this._applyVRange(this._vRange);\n                }\n            };\n            // updates in lit are performed asynchronously\n            requestAnimationFrame(fn);\n        };\n        this.getVRange = () => {\n            return this._vRange;\n        };\n        /**\n         * the vRange is synced to the native selection asynchronically\n         */\n        this.setVRange = (vRange) => {\n            this._editor.slots.vRangeUpdated.emit([vRange, 'other']);\n        };\n        /**\n         * sync the dom selection from vRange for **this Editor**\n         */\n        this.syncVRange = () => {\n            if (this._vRange) {\n                this._applyVRange(this._vRange);\n            }\n        };\n        /**\n         * calculate the dom selection from vRange for **this Editor**\n         */\n        this.toDomRange = (vRange) => {\n            const rootElement = this._editor.rootElement;\n            return virgoRangeToDomRange(rootElement, vRange);\n        };\n        /**\n         * calculate the vRange from dom selection for **this Editor**\n         * there are three cases when the vRange of this Editor is not null:\n         * (In the following, \"|\" mean anchor and focus, each line is a separate Editor)\n         * 1. anchor and focus are in this Editor\n         *    aaaaaa\n         *    b|bbbb|b\n         *    cccccc\n         *    the vRange of second Editor is {index: 1, length: 4}, the others are null\n         * 2. anchor and focus one in this Editor, one in another Editor\n         *    aaa|aaa    aaaaaa\n         *    bbbbb|b or bbbbb|b\n         *    cccccc     cc|cccc\n         *    2.1\n         *        the vRange of first Editor is {index: 3, length: 3}, the second is {index: 0, length: 5},\n         *        the third is null\n         *    2.2\n         *        the vRange of first Editor is null, the second is {index: 5, length: 1},\n         *        the third is {index: 0, length: 2}\n         * 3. anchor and focus are in another Editor\n         *    aa|aaaa\n         *    bbbbbb\n         *    cccc|cc\n         *    the vRange of first Editor is {index: 2, length: 4},\n         *    the second is {index: 0, length: 6}, the third is {index: 0, length: 4}\n         */\n        this.toVRange = (selection) => {\n            const { rootElement, yText } = this._editor;\n            return domRangeToVirgoRange(selection, rootElement, yText);\n        };\n        this.mergeRanges = (range1, range2) => {\n            return {\n                index: Math.max(range1.index, range2.index),\n                length: Math.min(range1.index + range1.length, range2.index + range2.length) -\n                    Math.max(range1.index, range2.index),\n            };\n        };\n        this.onScrollUpdated = (scrollLeft) => {\n            this._lastScrollLeft = scrollLeft;\n        };\n        this._applyVRange = (vRange) => {\n            if (!this._editor.isActive) {\n                return;\n            }\n            const selectionRoot = findDocumentOrShadowRoot(this._editor);\n            const selection = selectionRoot.getSelection();\n            if (!selection) {\n                return;\n            }\n            const newRange = this.toDomRange(vRange);\n            if (!newRange) {\n                return;\n            }\n            selection.removeAllRanges();\n            selection.addRange(newRange);\n            this._scrollLineIntoViewIfNeeded(newRange);\n            this._scrollCursorIntoViewIfNeeded(newRange);\n            this._editor.slots.rangeUpdated.emit(newRange);\n        };\n        this._scrollLineIntoViewIfNeeded = (range) => {\n            if (this._editor.shouldLineScrollIntoView) {\n                let lineElement = range.endContainer.parentElement;\n                while (!(lineElement instanceof VirgoLine)) {\n                    lineElement = lineElement?.parentElement ?? null;\n                }\n                lineElement?.scrollIntoView({\n                    block: 'nearest',\n                });\n            }\n        };\n        this._scrollCursorIntoViewIfNeeded = (range) => {\n            if (this._editor.shouldCursorScrollIntoView) {\n                const root = this._editor.rootElement;\n                const rootRect = root.getBoundingClientRect();\n                const rangeRect = range.getBoundingClientRect();\n                let moveX = 0;\n                if (rangeRect.left > rootRect.left) {\n                    moveX = Math.max(this._lastScrollLeft, rangeRect.left - rootRect.right);\n                }\n                root.scrollLeft = moveX;\n                this._lastScrollLeft = moveX;\n            }\n        };\n        this._editor = editor;\n    }\n}\n//# sourceMappingURL=range.js.map","export * from './attribute.js';\nexport * from './delta.js';\nexport * from './event.js';\nexport * from './range.js';\n//# sourceMappingURL=index.js.map","import { assertExists, Slot } from '@blocksuite/global/utils';\nimport { VirgoAttributeService, VirgoDeltaService, VirgoEventService, VirgoRangeService, } from './services/index.js';\nimport { findDocumentOrShadowRoot, nativePointToTextPoint, textPointToDomPoint, } from './utils/index.js';\nimport { calculateTextLength, getTextNodesFromElement } from './utils/text.js';\nclass VEditor {\n    get yText() {\n        return this._yText;\n    }\n    get rootElement() {\n        assertExists(this._rootElement);\n        return this._rootElement;\n    }\n    get eventService() {\n        return this._eventService;\n    }\n    get rangeService() {\n        return this._rangeService;\n    }\n    get attributeService() {\n        return this._attributeService;\n    }\n    get deltaService() {\n        return this._deltaService;\n    }\n    // Expose attribute service API\n    get marks() {\n        return this._attributeService.marks;\n    }\n    constructor(yText, ops) {\n        this._rootElement = null;\n        this._isReadonly = false;\n        this._eventService = new VirgoEventService(this);\n        this._rangeService = new VirgoRangeService(this);\n        this._attributeService = new VirgoAttributeService(this);\n        this._deltaService = new VirgoDeltaService(this);\n        this.shouldLineScrollIntoView = true;\n        this.shouldCursorScrollIntoView = true;\n        this.setAttributeSchema = this._attributeService.setAttributeSchema;\n        this.setAttributeRenderer = this._attributeService.setAttributeRenderer;\n        this.setMarks = this._attributeService.setMarks;\n        this.resetMarks = this._attributeService.resetMarks;\n        this.getFormat = this._attributeService.getFormat;\n        // Expose event service API\n        this.bindHandlers = this._eventService.bindHandlers;\n        // Expose range service API\n        this.toDomRange = this.rangeService.toDomRange;\n        this.toVRange = this.rangeService.toVRange;\n        this.getVRange = this.rangeService.getVRange;\n        this.setVRange = this.rangeService.setVRange;\n        this.syncVRange = this.rangeService.syncVRange;\n        // Expose delta service API\n        this.getDeltasByVRange = this.deltaService.getDeltasByVRange;\n        this.getDeltaByRangeIndex = this.deltaService.getDeltaByRangeIndex;\n        this.mapDeltasInVRange = this.deltaService.mapDeltasInVRange;\n        this._onYTextChange = () => {\n            if (this.yText.toString().includes('\\r')) {\n                throw new Error('yText must not contain \\r because it will break the range synchronization');\n            }\n            Promise.resolve().then(() => {\n                assertExists(this._rootElement);\n                this.deltaService.render();\n            });\n        };\n        if (!yText.doc) {\n            throw new Error('yText must be attached to a Y.Doc');\n        }\n        if (yText.toString().includes('\\r')) {\n            throw new Error('yText must not contain \\r because it will break the range synchronization');\n        }\n        this._yText = yText;\n        this._isActive = ops?.active ?? (() => true);\n        this.slots = {\n            mounted: new Slot(),\n            unmounted: new Slot(),\n            updated: new Slot(),\n            vRangeUpdated: new Slot(),\n            rangeUpdated: new Slot(),\n            scrollUpdated: new Slot(),\n        };\n        this.slots.vRangeUpdated.on(this.rangeService.onVRangeUpdated);\n        this.slots.scrollUpdated.on(this.rangeService.onScrollUpdated);\n    }\n    mount(rootElement) {\n        const virgoElement = rootElement;\n        virgoElement.virgoEditor = this;\n        this._rootElement = virgoElement;\n        this._rootElement.replaceChildren();\n        this._rootElement.contentEditable = 'true';\n        this._rootElement.dataset.virgoRoot = 'true';\n        this.yText.observe(this._onYTextChange);\n        this._deltaService.render();\n        this._eventService.mount();\n        this.slots.mounted.emit();\n    }\n    unmount() {\n        this._eventService.unmount();\n        this.yText.unobserve(this._onYTextChange);\n        this._rootElement?.replaceChildren();\n        this._rootElement = null;\n        this.slots.unmounted.emit();\n    }\n    requestUpdate() {\n        Promise.resolve().then(() => {\n            assertExists(this._rootElement);\n            this._deltaService.render();\n        });\n    }\n    getNativeSelection() {\n        const selectionRoot = findDocumentOrShadowRoot(this);\n        const selection = selectionRoot.getSelection();\n        if (!selection)\n            return null;\n        if (selection.rangeCount === 0)\n            return null;\n        return selection;\n    }\n    getTextPoint(rangeIndex) {\n        assertExists(this._rootElement);\n        const vLines = Array.from(this._rootElement.querySelectorAll('v-line'));\n        let index = 0;\n        for (const vLine of vLines) {\n            const texts = VEditor.getTextNodesFromElement(vLine);\n            for (const text of texts) {\n                if (!text.textContent) {\n                    throw new Error('text element should have textContent');\n                }\n                if (index + text.textContent.length >= rangeIndex) {\n                    return [text, rangeIndex - index];\n                }\n                index += calculateTextLength(text);\n            }\n            index += 1;\n        }\n        throw new Error('failed to find leaf');\n    }\n    // the number is related to the VirgoLine's textLength\n    getLine(rangeIndex) {\n        assertExists(this._rootElement);\n        const lineElements = Array.from(this._rootElement.querySelectorAll('v-line'));\n        let index = 0;\n        for (const lineElement of lineElements) {\n            if (rangeIndex >= index && rangeIndex <= index + lineElement.textLength) {\n                return [lineElement, rangeIndex - index];\n            }\n            if (rangeIndex === index + lineElement.textLength &&\n                rangeIndex === this.yText.length) {\n                return [lineElement, rangeIndex - index];\n            }\n            index += lineElement.textLength + 1;\n        }\n        throw new Error('failed to find line');\n    }\n    setReadonly(isReadonly) {\n        this.rootElement.contentEditable = isReadonly ? 'false' : 'true';\n        this._isReadonly = isReadonly;\n    }\n    get isReadonly() {\n        return this._isReadonly;\n    }\n    get isActive() {\n        return this._isActive();\n    }\n    /**\n     * the vRange is synced to the native selection asynchronically\n     */\n    focusEnd() {\n        this.rangeService.setVRange({\n            index: this.yText.length,\n            length: 0,\n        });\n    }\n    deleteText(vRange) {\n        this._transact(() => {\n            this.yText.delete(vRange.index, vRange.length);\n        });\n    }\n    insertText(vRange, text, attributes = {}) {\n        if (this._attributeService.marks) {\n            attributes = { ...attributes, ...this._attributeService.marks };\n        }\n        const normalizedAttributes = this._attributeService.normalizeAttributes(attributes);\n        if (!text || !text.length) {\n            throw new Error('text must not be empty');\n        }\n        this._transact(() => {\n            this.yText.delete(vRange.index, vRange.length);\n            this.yText.insert(vRange.index, text, normalizedAttributes);\n        });\n    }\n    insertLineBreak(vRange) {\n        this._transact(() => {\n            this.yText.delete(vRange.index, vRange.length);\n            this.yText.insert(vRange.index, '\\n');\n        });\n    }\n    formatText(vRange, attributes, options = {}) {\n        const { match = () => true, mode = 'merge' } = options;\n        const deltas = this._deltaService.getDeltasByVRange(vRange);\n        deltas\n            .filter(([delta, deltaVRange]) => match(delta, deltaVRange))\n            .forEach(([delta, deltaVRange]) => {\n            const targetVRange = this._rangeService.mergeRanges(vRange, deltaVRange);\n            if (mode === 'replace') {\n                this.resetText(targetVRange);\n            }\n            this._transact(() => {\n                this.yText.format(targetVRange.index, targetVRange.length, attributes);\n            });\n        });\n    }\n    resetText(vRange) {\n        const coverDeltas = [];\n        for (let i = vRange.index; i <= vRange.index + vRange.length; i++) {\n            const delta = this.getDeltaByRangeIndex(i);\n            if (delta) {\n                coverDeltas.push(delta);\n            }\n        }\n        const unset = Object.fromEntries(coverDeltas.flatMap(delta => delta.attributes\n            ? Object.keys(delta.attributes).map(key => [key, null])\n            : []));\n        this._transact(() => {\n            this.yText.format(vRange.index, vRange.length, {\n                ...unset,\n            });\n        });\n    }\n    setText(text, attributes = {}) {\n        this._transact(() => {\n            this.yText.delete(0, this.yText.length);\n            this.yText.insert(0, text, attributes);\n        });\n    }\n    _transact(fn) {\n        const doc = this.yText.doc;\n        if (!doc) {\n            throw new Error('yText is not attached to a doc');\n        }\n        doc.transact(fn, doc.clientID);\n    }\n}\nVEditor.nativePointToTextPoint = nativePointToTextPoint;\nVEditor.textPointToDomPoint = textPointToDomPoint;\nVEditor.getTextNodesFromElement = getTextNodesFromElement;\nexport { VEditor };\n//# sourceMappingURL=virgo.js.map","/// <reference types=\"@blocksuite/global\" />\nexport * from './components/index.js';\nexport * from './consts.js';\nexport * from './services/index.js';\nexport * from './types.js';\nexport * from './utils/index.js';\nexport * from './virgo.js';\n//# sourceMappingURL=index.js.map","import{_$LH as o}from\"./lit-html.js\";\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */const{I:l}=o,t=o=>null===o||\"object\"!=typeof o&&\"function\"!=typeof o,i={HTML:1,SVG:2},n=(o,l)=>void 0===l?void 0!==(null==o?void 0:o._$litType$):(null==o?void 0:o._$litType$)===l,d=o=>void 0!==(null==o?void 0:o._$litDirective$),v=o=>null==o?void 0:o._$litDirective$,e=o=>void 0===o.strings,c=()=>document.createComment(\"\"),r=(o,t,i)=>{var n;const d=o._$AA.parentNode,v=void 0===t?o._$AB:t._$AA;if(void 0===i){const t=d.insertBefore(c(),v),n=d.insertBefore(c(),v);i=new l(t,n,o,o.options)}else{const l=i._$AB.nextSibling,t=i._$AM,e=t!==o;if(e){let l;null===(n=i._$AQ)||void 0===n||n.call(i,o),i._$AM=o,void 0!==i._$AP&&(l=o._$AU)!==t._$AU&&i._$AP(l)}if(l!==v||e){let o=i._$AA;for(;o!==l;){const l=o.nextSibling;d.insertBefore(o,v),o=l}}}return i},u=(o,l,t=o)=>(o._$AI(l,t),o),f={},s=(o,l=f)=>o._$AH=l,m=o=>o._$AH,p=o=>{var l;null===(l=o._$AP)||void 0===l||l.call(o,!1,!0);let t=o._$AA;const i=o._$AB.nextSibling;for(;t!==i;){const o=t.nextSibling;t.remove(),t=o}},a=o=>{o._$AR()};export{i as TemplateResultType,a as clearPart,m as getCommittedValue,v as getDirectiveClass,r as insertPart,d as isDirectiveResult,t as isPrimitive,e as isSingleExpression,n as isTemplateResult,p as removePart,u as setChildPartValue,s as setCommittedValue};\n//# sourceMappingURL=directive-helpers.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst t={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},e=t=>(...e)=>({_$litDirective$:t,values:e});class i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}export{i as Directive,t as PartType,e as directive};\n//# sourceMappingURL=directive.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst e=e=>n=>\"function\"==typeof n?((e,n)=>(customElements.define(e,n),n))(e,n):((e,n)=>{const{kind:t,elements:s}=n;return{kind:t,elements:s,finisher(n){customElements.define(e,n)}}})(e,n);export{e as customElement};\n//# sourceMappingURL=custom-element.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst i=(i,e)=>\"method\"===e.kind&&e.descriptor&&!(\"value\"in e.descriptor)?{...e,finisher(n){n.createProperty(e.key,i)}}:{kind:\"field\",key:Symbol(),placement:\"own\",descriptor:{},originalKey:e.key,initializer(){\"function\"==typeof e.initializer&&(this[e.key]=e.initializer.call(this))},finisher(n){n.createProperty(e.key,i)}};function e(e){return(n,t)=>void 0!==t?((i,e,n)=>{e.constructor.createProperty(n,i)})(e,n,t):i(e,n)}export{e as property};\n//# sourceMappingURL=property.js.map\n","import{property as r}from\"./property.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */function t(t){return r({...t,state:!0})}export{t as state};\n//# sourceMappingURL=state.js.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst e=(e,t,o)=>{Object.defineProperty(t,o,e)},t=(e,t)=>({kind:\"method\",placement:\"prototype\",key:t.key,descriptor:e}),o=({finisher:e,descriptor:t})=>(o,n)=>{var r;if(void 0===n){const n=null!==(r=o.originalKey)&&void 0!==r?r:o.key,i=null!=t?{kind:\"method\",placement:\"prototype\",key:n,descriptor:t(o.key)}:{...o,key:n};return null!=e&&(i.finisher=function(t){e(t,n)}),i}{const r=o.constructor;void 0!==t&&Object.defineProperty(o,n,t(n)),null==e||e(r,n)}};export{o as decorateProperty,e as legacyPrototypeMethod,t as standardPrototypeMethod};\n//# sourceMappingURL=base.js.map\n","import{decorateProperty as o}from\"./base.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */function i(i,n){return o({descriptor:o=>{const t={get(){var o,n;return null!==(n=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==n?n:null},enumerable:!0,configurable:!0};if(n){const n=\"symbol\"==typeof o?Symbol():\"__\"+o;t.get=function(){var o,t;return void 0===this[n]&&(this[n]=null!==(t=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==t?t:null),this[n]}}return t}})}export{i as query};\n//# sourceMappingURL=query.js.map\n","import{decorateProperty as r}from\"./base.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */function e(e){return r({descriptor:r=>({get(){var r,o;return null!==(o=null===(r=this.renderRoot)||void 0===r?void 0:r.querySelectorAll(e))&&void 0!==o?o:[]},enumerable:!0,configurable:!0})})}export{e as queryAll};\n//# sourceMappingURL=query-all.js.map\n","import{decorateProperty as o}from\"./base.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */var n;const e=null!=(null===(n=window.HTMLSlotElement)||void 0===n?void 0:n.prototype.assignedElements)?(o,n)=>o.assignedElements(n):(o,n)=>o.assignedNodes(n).filter((o=>o.nodeType===Node.ELEMENT_NODE));function l(n){const{slot:l,selector:t}=null!=n?n:{};return o({descriptor:o=>({get(){var o;const r=\"slot\"+(l?`[name=${l}]`:\":not([name])\"),i=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(r),s=null!=i?e(i,n):[];return t?s.filter((o=>o.matches(t))):s},enumerable:!0,configurable:!0})})}export{l as queryAssignedElements};\n//# sourceMappingURL=query-assigned-elements.js.map\n","import{decorateProperty as e}from\"./base.js\";import{queryAssignedElements as t}from\"./query-assigned-elements.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */function o(o,n,r){let l,s=o;return\"object\"==typeof o?(s=o.slot,l=o):l={flatten:n},r?t({slot:s,flatten:n,selector:r}):e({descriptor:e=>({get(){var e,t;const o=\"slot\"+(s?`[name=${s}]`:\":not([name])\"),n=null===(e=this.renderRoot)||void 0===e?void 0:e.querySelector(o);return null!==(t=null==n?void 0:n.assignedNodes(l))&&void 0!==t?t:[]},enumerable:!0,configurable:!0})})}export{o as queryAssignedNodes};\n//# sourceMappingURL=query-assigned-nodes.js.map\n","export*from\"@lit/reactive-element/decorators/custom-element.js\";export*from\"@lit/reactive-element/decorators/property.js\";export*from\"@lit/reactive-element/decorators/state.js\";export*from\"@lit/reactive-element/decorators/event-options.js\";export*from\"@lit/reactive-element/decorators/query.js\";export*from\"@lit/reactive-element/decorators/query-all.js\";export*from\"@lit/reactive-element/decorators/query-async.js\";export*from\"@lit/reactive-element/decorators/query-assigned-elements.js\";export*from\"@lit/reactive-element/decorators/query-assigned-nodes.js\";\n//# sourceMappingURL=decorators.js.map\n","import{noChange as e}from\"../lit-html.js\";import{directive as s,Directive as t,PartType as r}from\"../directive.js\";import{getCommittedValue as l,setChildPartValue as o,insertPart as i,removePart as n,setCommittedValue as f}from\"../directive-helpers.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst u=(e,s,t)=>{const r=new Map;for(let l=s;l<=t;l++)r.set(e[l],l);return r},c=s(class extends t{constructor(e){if(super(e),e.type!==r.CHILD)throw Error(\"repeat() can only be used in text expressions\")}dt(e,s,t){let r;void 0===t?t=s:void 0!==s&&(r=s);const l=[],o=[];let i=0;for(const s of e)l[i]=r?r(s,i):i,o[i]=t(s,i),i++;return{values:o,keys:l}}render(e,s,t){return this.dt(e,s,t).values}update(s,[t,r,c]){var d;const a=l(s),{values:p,keys:v}=this.dt(t,r,c);if(!Array.isArray(a))return this.ht=v,p;const h=null!==(d=this.ht)&&void 0!==d?d:this.ht=[],m=[];let y,x,j=0,k=a.length-1,w=0,A=p.length-1;for(;j<=k&&w<=A;)if(null===a[j])j++;else if(null===a[k])k--;else if(h[j]===v[w])m[w]=o(a[j],p[w]),j++,w++;else if(h[k]===v[A])m[A]=o(a[k],p[A]),k--,A--;else if(h[j]===v[A])m[A]=o(a[j],p[A]),i(s,m[A+1],a[j]),j++,A--;else if(h[k]===v[w])m[w]=o(a[k],p[w]),i(s,a[j],a[k]),k--,w++;else if(void 0===y&&(y=u(v,w,A),x=u(h,j,k)),y.has(h[j]))if(y.has(h[k])){const e=x.get(v[w]),t=void 0!==e?a[e]:null;if(null===t){const e=i(s,a[j]);o(e,p[w]),m[w]=e}else m[w]=o(t,p[w]),i(s,a[j],t),a[e]=null;w++}else n(a[k]),k--;else n(a[j]),j++;for(;w<=A;){const e=i(s,m[A+1]);o(e,p[w]),m[w++]=e}for(;j<=k;){const e=a[j++];null!==e&&n(e)}return this.ht=v,f(s,m),e}});export{c as repeat};\n//# sourceMappingURL=repeat.js.map\n","export*from\"lit-html/directives/repeat.js\";\n//# sourceMappingURL=repeat.js.map\n","import{noChange as t}from\"../lit-html.js\";import{directive as e,Directive as r,PartType as s}from\"../directive.js\";\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */const i=\"important\",n=\" !\"+i,o=e(class extends r{constructor(t){var e;if(super(t),t.type!==s.ATTRIBUTE||\"style\"!==t.name||(null===(e=t.strings)||void 0===e?void 0:e.length)>2)throw Error(\"The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.\")}render(t){return Object.keys(t).reduce(((e,r)=>{const s=t[r];return null==s?e:e+`${r=r.includes(\"-\")?r:r.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g,\"-$&\").toLowerCase()}:${s};`}),\"\")}update(e,[r]){const{style:s}=e.element;if(void 0===this.ut){this.ut=new Set;for(const t in r)this.ut.add(t);return this.render(r)}this.ut.forEach((t=>{null==r[t]&&(this.ut.delete(t),t.includes(\"-\")?s.removeProperty(t):s[t]=\"\")}));for(const t in r){const e=r[t];if(null!=e){this.ut.add(t);const r=\"string\"==typeof e&&e.endsWith(n);t.includes(\"-\")||r?s.setProperty(t,r?e.slice(0,-11):e,r?i:\"\"):s[t]=e}}return t}});export{o as styleMap};\n//# sourceMappingURL=style-map.js.map\n","export*from\"lit-html/directives/style-map.js\";\n//# sourceMappingURL=style-map.js.map\n"],"names":["ActiveEditorManager","constructor","activeSlot","_blocksuite_global_utils__WEBPACK_IMPORTED_MODULE_0__","g","clearActive","undefined","activeElement","emit","isActive","ele","contains","setActive","setIfNoActive","getActiveEditor","activeEditorManager","getCurrentBlockRange","page","pageBlock","_query_js__WEBPACK_IMPORTED_MODULE_1__","U6","selectedBlocks","selection","state","selectedEmbeds","models","map","element","mt","filter","Boolean","length","type","startOffset","endOffset","text","_selection_js__WEBPACK_IMPORTED_MODULE_2__","hasNativeSelection","range","getCurrentNativeRange","blockRange","nativeRangeToBlockRange","nativeRange","blockRangeToNativeRange","pageElement","titleVEditor","startNode","getTextPoint","endNode","Range","setStart","setEnd","model","getTextNodeByModel","pS","startVRange","getVRangeByNode","startContainer","endVRange","endContainer","index","updateBlockRange","oldModel","newModel","restoreSelection","defaultPageBlock","resetNativeSelection","clearBlockSelection","refreshSelectedBlocksRectsByModels","document","blur","focusTitle","getExtendBlockRange","basicBlockRange","isTitleRange","zv","pageModel","root","_blocksuite_store__WEBPACK_IMPORTED_MODULE_0__","kP","node","parentElement","virgoElement","closest","HTMLElement","querySelector","vEditor","virgoEditor","getVRange","offset","gj","leaf","leafOffset","experimentCreateBlockRange","cacheRange","rangeOrBlockRange","getRange","startModel","endModel","betweenModels","slice","collapsed","apply","asyncSetVRange","vRange","richText","_query_js__WEBPACK_IMPORTED_MODULE_0__","w_","setVRange","Promise","resolve","slots","rangeUpdated","once","asyncFocusRichText","id","getBlockById","_blocksuite_global_utils__WEBPACK_IMPORTED_MODULE_1__","h$","isCollapsedAtBlockStart","isInSamePath","children","father","parent","getParent","convertToList","listType","prefix","otherProperties","indexOf","insert","captureSync","delete","blockProps","clone","deleteBlock","addBlock","updateBlock","convertToParagraph","convertToDivider","nextBlock","nextId","createBookmarkBlock","parentModel","url","requestAnimationFrame","_b","openInitialModal","createImageInputElement","fileInput","createElement","multiple","accept","style","position","left","top","opacity","uploadImageFromLocal","getSize","resolvePromise","baseProps","flavour","body","appendChild","pending","onChange","files","storage","blobs","file","width","height","reader","FileReader","addEventListener","_","img","Image","onload","src","result","readAsDataURL","set","sourceId","res","i","push","removeEventListener","remove","click","isff","navigator","userAgent","toLowerCase","addEvent","object","event","method","useCapture","attachEvent","concat","window","getMods","modifier","key","mods","getKeys","keys","replace","split","lastIndexOf","splice","_keyMap","backspace","tab","clear","enter","return","esc","escape","space","up","right","down","del","ins","home","end","pageup","pagedown","capslock","num_0","num_1","num_2","num_3","num_4","num_5","num_6","num_7","num_8","num_9","num_multiply","num_add","num_enter","num_subtract","num_decimal","num_divide","_modifier","shift","alt","option","ctrl","control","cmd","command","modifierMap","shiftKey","ctrlKey","altKey","metaKey","_mods","_handlers","k","_downKeys","winListendFocus","_scope","elementHasBindEvent","code","x","toUpperCase","charCodeAt","setScope","scope","getScope","eachUnbind","_ref","_ref$splitKey","splitKey","multipleKeys","forEach","originKey","unbindKeys","len","lastKey","keyCode","record","isMatchingMethod","compareArray","a1","a2","arr1","arr2","isIndex","eventHandler","handler","modifiersMatch","y","Object","prototype","hasOwnProperty","call","shortcut","preventDefault","returnValue","stopPropagation","cancelBubble","dispatch","asterisk","which","charCode","hotkeys","keyName","keyNum","e","getModifierState","keydown","keyup","_i","keyShortcut","_downKeysCurrent","a","sort","join","capture","toString","clearModifier","_api","getPressedKeyString","c","getKey","find","String","fromCharCode","deleteScope","newScope","handlers","getPressedKeyCodes","isPressed","target","srcElement","tagName","flag","isContentEditable","readOnly","trigger","arguments","dataList","item","data","unbind","keysInfo","Array","isArray","info","_len","args","_key","keyMap","_hotkeys","noConflict","deep","isUndoRedo","shouldFilterHotkey","query","zg","Fe","Yb","Rn","ok","HOTKEY_SCOPE_TYPE","AFFINE_PAGE","AFFINE_EDGELESS","HOTKEY_DISABLED_SCOPE","hotkey","_disabled","counter","disabled","addListener","listener","options","removeListener","disableHotkey","enableHotkey","withDisabledHotkey","fn","withDisabledHotkeyFn","withScope","pre","calcDropTarget","point","draggingElements","scale","schema","getSchemaByFlavour","utils","shouldAppendToDatabase","gc","every","m","includes","databaseBlockElement","rect","domRect","XZ","pw","EmptyDatabase","utils_rect","U","fromDOMRect","modelState","Database","distanceToTop","Math","abs","distanceToBottom","bottom","before","fromLWTH","offsetY","prev","prevRect","previousElementSibling","az","getBoundingClientRect","next","nextElementSibling","I8","nextRect","isPinchEvent","cj","platform","Mq","createDragEvent","dataTransfer","DataTransfer","clientX","clientY","screenX","screenY","assign","DragEvent","bringForward","ranges","elements","start","temp","sendBackward","reorderTo","compare","getIndexes","genKeys","setIndexes","reorder","pick","order","pickedElements","indexes","b","findIndex","generateRanges","curr","getPreviousBlock","parentBlock","previousBlock","getPreviousSibling","_blocksuite_global_utils__WEBPACK_IMPORTED_MODULE_4__","lastChild","getNextBlock","currentBlock","nextSibling","getNextSibling","DropFlags","ATTR_SELECTOR","_blocksuite_global_config__WEBPACK_IMPORTED_MODULE_3__","SF","getParentBlockById","getBlockElementById","getPageBlock","getDefaultPage","editor","getEditorContainer","mode","pageComponent","getEdgelessPage","editorContainer","getEditorContainerByElement","isPageMode","getViewportElement","isPage","viewportElement","getBlockElementByModel","_internal_utils_active_editor_manager_js__WEBPACK_IMPORTED_MODULE_0__","asyncGetBlockElementByModel","resolved","reject","onSuccess","observer","disconnect","onFail","MutationObserver","blockElement","observe","childList","subtree","getStartModelBySelection","Text","startComponent","getRichTextByModel","asyncGetRichTextByModel","getVirgoByModel","asyncGetVirgoByModel","getModelsByRange","nodeType","Node","COMMENT_NODE","commonAncestorContainer","commonAncestor","TEXT_NODE","attributes","getNamedItem","intersectedModels","blockElements","querySelectorAll","from","block","mainElement","intersectsNode","getModelByElement","closestBlock","getModelByBlockElement","mergeRect","DOMRect","min","max","getDOMRectByLine","rectList","lineType","list","subList","reduce","isInsideRichText","Event","Element","isInsidePageTitle","titleElement","isInsideEdgelessTextEditor","textElement","isToggleIcon","SVGPathElement","getAttribute","isDatabaseInput","isRawInput","HTMLInputElement","isInsideDatabaseTitle","isCaptionElement","classList","getElementFromEventTarget","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","isContainedIn","some","hasBlockId","hasAttribute","isDefaultPage","isEdgelessPage","isPageOrFrameOrSurface","isFrame","isSurface","isBlock","isImage","firstElementChild","isDatabase","isEdgelessBlockChild","getClosestBlockElementByPoint","container","bounds","childBounds","diff","n","snapToEdge","qL","console","warn","_std_js__WEBPACK_IMPORTED_MODULE_5__","uZ","findBlockElement","elementsFromPoint","rows","getDatabaseBlockRowsElement","getRectByBlockElement","STEPS","MAX_SPACE","getClosestBlockElementByElement","loader","hostModel","containerBlock","getBlockElementsByElement","getClosestFrameBlockElementById","getSelectedStateRectByBlockElement","wrapper","resizable","w","_rect_js__WEBPACK_IMPORTED_MODULE_6__","fromDOM","r","d","intersect","toDOMRect","getBlockElementsExcludeSubtrees","getBlockElementsIncludeSubtrees","isEmbed","queryCurrentMode","getComputedStyle","documentElement","getPropertyValue","trim","getHoveringFrame","isEmptyDatabase","isEmpty","getDatabaseBlockTableElement","getDatabaseBlockColumnHeaderElement","getDropRectByPoint","Normal","table","header","rowsBounds","getCellRect","col","row","colRect","rowRect","isElement","isSelectedBlocks","isDragHandle","hasDatabase","Point","equals","add","factor","subtract","clamp","p","_std_js__WEBPACK_IMPORTED_MODULE_0__","Rect","minX","maxX","minY","maxY","h","center","extend_with","extend_with_x","extend_with_y","isPointIn","intersects","isPointDown","isPointUp","isPointLeft","isPointRight","other","fromPoints","fromLTRB","fromXY","fromPoint","dom","notStrictCharacterReg","notStrictCharacterAndSpaceReg","setStartRange","editableContainer","newRange","createRange","firstNode","firstChild","setEndRange","lastNode","textContent","setNewTop","zoom","scrollContainer","_rect_js__WEBPACK_IMPORTED_MODULE_3__","clientHeight","lineHeight","Number","finalBottom","_blocksuite_global_config__WEBPACK_IMPORTED_MODULE_4__","zQ","scrollTop","finalTop","Infinity","_query_js__WEBPACK_IMPORTED_MODULE_2__","yText","focusRichText","scrollIntoView","newLeft","newTop","_blocksuite_global_utils__WEBPACK_IMPORTED_MODULE_5__","Qo","focusBlockByModel","_blocksuite_global_utils__WEBPACK_IMPORTED_MODULE_6__","De","clearSelection","selectedRectsUpdated","child","setFocusedBlock","focusPreviousBlock","nextPosition","lastSelectionPosition","preNodeModel","nt","focusNextBlock","nextNodeModel","st","getSelection","removeAllRanges","addRange","rangeCount","isCollapsedNativeSelection","isCollapsed","isRangeNativeSelection","isMultiBlockRange","isMultiLineRange","oneLineRange","oneLineHeight","getRangeAt","handleNativeRangeDragMove","startRange","currentRange","isEdgelessMode","raw","_startContainer","startFrame","currentFrame","shouldUpdateCurrentRange","el","elementFromPoint","currentEditor","getClosestFrame","closestEditor","getClosestEditor","newPoint","normalizePointIntoContainer","isBackward","comparePoint","isBlankArea","cursor","handleNativeRangeClick","button","handleNativeRangeAtPoint","retargetClick","targetElement","Mg","shouldRetarget","horizontalElement","G8","_common_operations_js__WEBPACK_IMPORTED_MODULE_1__","a6","handleNativeRangeDblClick","anchorNode","expandRangeByCharacter","leafNodes","leftFirstSearchLeafNodes","currentChar","currentNodeIndex","getNewRangeForDblClick","currentTextNode","anchorOffset","test","checkReg","newStartNode","newStartOffset","newEndNode","newEndOffset","getNewStartAndEndForDblClick","reverseText","reverse","search","j","extendRange","trySelectBySegmenter","Intl","Segmenter","currentCharIndex","wordText","getCurrentCharIndex","rangeString","segmenter","granularity","wordsIterator","segment","Symbol","iterator","words","absoluteOffset","started","leafNode","word","leftLength","rightLength","allTextLength","textLength","childNodes","getLastTextNode","pop","getFirstTextNode","getSplicedTitle","title","value","selectionStart","selectionEnd","getHorizontalClosestElement","selector","mid","floor","minElement","handleNativeRangeTripleClick","textNodes","_blocksuite_virgo__WEBPACK_IMPORTED_MODULE_0__","IP","first","last","found","supportsChildren","almostEqual","createEvent","detail","CustomEvent","noop","throttle","limit","leading","trailing","timer","lastArgs","setTimer","setTimeout","debounce","clearTimeout","countBy","items","count","maxBy","maxItem","v","isControlledKeyboardEvent","isPrintableKeyEvent","atLeastNMatches","arr","matchFn","groupBy","groupKey","isFuzzyMatch","name","pureName","char","regex","input","toHex","color","startsWith","substr","match","hex","parseInt","repeat","capitalize","s","uncapitalize","BrushSize","AbstractSelectionManager","dispatcher","_disposables","SJ","_dispatcher","ZERO_WIDTH_SPACE","ZERO_WIDTH_NON_JOINER","getDefaultAttributeRenderer","delta","props","textDecorations","inlineCodeStyle","underline","strike","background","padding","style_map","V","bold","italic","lit","dy","__decorate","decorators","desc","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","VirgoElement","oi","attributeRenderer","render","createRenderRoot","Cb","Function","attribute","Mo","virgo_line_decorate","VirgoLine","vElements","acc","getUpdateComplete","all","updateComplete","firstUpdated","display","virgo_text_decorate","VText","str","styles","baseTextAttributes","lib","z","literal","optional","catch","link","string","transformDelta","tmpString","calculateTextLength","wholeText","getTextNodesFromElement","textSpanElements","textSpanElement","textNode","nativePointToTextPoint","dataset","virgoText","texts","textOffset","isVLine","virgoRoot","getTextPointFromElementByOffset","vNodes","getVNodesFromNode","vLine","getTextPointFromVNodes","AFollowedByB","DOCUMENT_POSITION_FOLLOWING","APrecededByB","getTextPointFromElement","textPointToDomPoint","rootElement","goalIndex","textParentElement","lineElement","lineIndex","fromStart","DOCUMENT_POSITION_PRECEDING","findDocumentOrShadowRoot","getRootNode","Document","ShadowRoot","ownerDocument","isSelectionBackwards","backwards","focusNode","focusOffset","detach","rangeHasAnchorAndFocus","anchorText","focusText","rangeHasAnchorAndFocusHandler","anchorTextOffset","focusTextOffset","anchorDomPoint","focusDomPoint","rangeOnlyHasFocus","rangeOnlyHasFocusHandler","rangeOnlyHasAnchor","rangeOnlyHasAnchorHandler","rangeHasNoAnchorAndFocus","rangeHasNoAnchorAndFocusHandler","buildContext","anchorTextPoint","focusTextPoint","VirgoAttributeService","_marks","_attributeRenderer","_attributeSchema","setMarks","marks","resetMarks","setAttributeSchema","setAttributeRenderer","renderer","getFormat","loose","deltas","_editor","deltaService","getDeltasByVRange","maybeAttributesList","cur","attributesList","newFormat","typedKey","normalizeAttributes","textAttributes","attributeResult","safeParse","success","error","fromEntries","entries","VirgoDeltaService","mapDeltasInVRange","callback","to","deltaInRange","getDeltaByRangeIndex","rangeIndex","chunks","deltaInsertsToChunks","transformedDelta","flatMap","chunksGenerator","chunk","at","lines","elementTs","parseAttributes","attributeService","sY","line","entry","requestUpdate","vLines","rangeService","syncVRange","updated","toDelta","VirgoEventService","_mountAbortController","_handlerAbortController","_isComposing","_previousAnchor","_previousFocus","defaultHandlers","paste","clipboardData","getData","insertText","mount","AbortController","_onSelectionChange","signal","_onBeforeInput","_onCompositionStart","_onCompositionEnd","_onScroll","bindHandlers","unmount","abort","selectionRoot","focusEnd","toVRange","vRangeUpdated","isReadonly","ctx","skipDefault","virgoCompositionEnd","newVRange","vText","forgedVText","virgoTextValue","toDomRange","_firstRecomputeInFrame","virgoInput","newEvent","transformInput","inputType","insertLineBreak","handleDelete","deleteText","originalString","segments","deletedLength","handleWordDelete","matches","exec","deleteLength","handleLineDelete","handleForwardDelete","slicedString","slicedSegments","scrollUpdated","scrollLeft","VirgoRangeService","_vRange","_lastScrollLeft","onVRangeUpdated","origin","dispatchEvent","_applyVRange","virgoRangeToDomRange","lineElements","domRangeToVirgoRange","context","mergeRanges","range1","range2","onScrollUpdated","_scrollLineIntoViewIfNeeded","_scrollCursorIntoViewIfNeeded","shouldLineScrollIntoView","shouldCursorScrollIntoView","rootRect","rangeRect","moveX","VEditor","_yText","_rootElement","eventService","_eventService","_rangeService","_attributeService","_deltaService","ops","_isReadonly","_onYTextChange","then","doc","_isActive","active","mounted","slot","unmounted","on","replaceChildren","contentEditable","unobserve","getNativeSelection","getLine","setReadonly","_transact","normalizedAttributes","formatText","deltaVRange","targetVRange","resetText","format","coverDeltas","unset","setText","transact","clientID","I","l","_lit_html_js__WEBPACK_IMPORTED_MODULE_0__","Al","createComment","o","t","_$AA","parentNode","_$AB","insertBefore","_$AM","_$AQ","_$AP","_$AU","u","_$AI","f","_$AH","ATTRIBUTE","CHILD","PROPERTY","BOOLEAN_ATTRIBUTE","EVENT","ELEMENT","_$litDirective$","values","_$AT","_$Ct","_$Ci","_$AS","update","custom_element_e","customElements","define","kind","finisher","descriptor","placement","originalKey","initializer","createProperty","property_e","state_t","base_o","query_i","get","renderRoot","enumerable","configurable","query_all_e","HTMLSlotElement","assignedElements","assignedNodes","ELEMENT_NODE","Map","directive","XM","Xe","pX","Error","dt","directive_helpers","i9","ht","A","fk","_Y","has","ws","hl","lit_html","Jb","strings","ut","Set","removeProperty","endsWith","setProperty"],"sourceRoot":""}